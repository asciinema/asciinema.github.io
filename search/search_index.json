{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<pre>\n  __ _ ___  ___(_|_)_ __   ___ _ __ ___   __ _\n / _` / __|/ __| | | '_ \\ / _ \\ '_ ` _ \\ / _` |\n| (_| \\__ \\ (__| | | | | |  __/ | | | | | (_| |\n \\__,_|___/\\___|_|_|_| |_|\\___|_| |_| |_|\\__,_|\n</pre> <p>asciinema is a suite of tools for recording, streaming, and sharing terminal sessions. It is free and open-source software (FOSS), created by Marcin Kulik.</p> <p>Its typical use cases include creating tutorials, demonstrating command-line tools, live coding, and sharing reproducible bug reports. It focuses on simplicity and interoperability, which makes it a popular choice among computer users working with the command-line, such as developers or system administrators.</p> <ul> <li> <p>Learn about the project</p> <p>Learn how asciinema works, how to engage with the community, what integrations people have built around the project, and last but not least, how to support the project.</p> </li> <li> <p>Get started</p> <p>To get up to speed with asciinema, follow the getting started guide. It's a short, hands-on tutorial, which demonstrates what's possible, and leaves you with a good high-level overview of the tool.</p> </li> <li> <p>Dive deeper</p> <p>To get deeper, navigate to the manual, which covers installation, configuration and usage of each asciinema component (CLI, player, server). It also includes the specification of the file format used by asciinema.</p> </li> </ul> <p>If you're looking for something specific you can use the search bar at the top of the page.</p>"},{"location":"community/","title":"Community","text":""},{"location":"community/#mastodon","title":"Mastodon","text":"<p>To stay updated follow @asciinema@fosstodon.org on Mastodon. Posts include updates on new releases, development insights, tips &amp; tricks.</p> <p>When posting about asciinema don't forget to use <code>#asciinema</code> hashtag!</p> <p>Please don't use Mastodon to report bugs or seek help. Instead use one of the alternatives below (help), or use an issue tracker (bugs).</p>"},{"location":"community/#forum","title":"Forum","text":"<p>Join asciinema discussion forum to discuss all things related to asciinema.</p> <p>If you've created a cool integration, have an idea for a feature, or are seeking help from the community, then this is a good place to start a conversation.</p>"},{"location":"community/#matrix","title":"Matrix","text":"<p>For real-time chat with other asciinema users join the <code>#asciinema:matrix.org</code> room on the Matrix network. You can use a web client to join the room. Element is a good choice if you're not familiar with Matrix.</p>"},{"location":"community/#irc","title":"IRC","text":"<p>Another option for real-time chat is good old IRC. Join <code>#asciinema</code> channel on Libera.Chat. You can use a web client to join the channel.</p>"},{"location":"consulting/","title":"Consulting","text":"<p>Hello there! I'm Marcin Kulik, the lead developer of asciinema project.</p> <p>I offer consulting services for asciinema project, which bring over a decade of experience in building and refining solutions for terminal session recording, sharing and streaming. Whether you're looking to integrate asciinema into your infrastructure or website, to customize it to suit your specific needs, or to create something new in this space, I'm happy to help.</p> <p>I work with enterprises, startups and individuals.</p>"},{"location":"consulting/#services","title":"Services","text":"<p>Non-exhaustive list of services for asciinema:</p> <ul> <li>integration of asciinema player in your website,</li> <li>building customized version of asciinema player to   suit your needs,</li> <li>integration of asciinema recorder in your software   solutions,</li> <li>installation and adaptation of asciinema server to   your infrastructure (on-premise, in the cloud),</li> <li>long term support for asciinema server (upgrades),</li> <li>embedding of asciinema virtual terminal in   your software,</li> <li>adapting asciinema gif generator for a different input   or output format.</li> </ul> <p>With 20 years of professional experience I also help with topics beyond asciinema, e.g:</p> <ul> <li>designing efficient binary network protocols tailored towards real-time   use-cases and low-latency interactivity,</li> <li>identifying causes of software bloat/slowness, optimizing the heck out of it.</li> </ul> <p>Happy to discuss other topics as well.</p>"},{"location":"consulting/#examples","title":"Examples","text":"<p>A selection of work completed for my clients:</p> <ul> <li>WASM-powered session playback - see 4x smaller, 50x faster post.</li> <li>automatic recording and uploading: setting up asciinema recorder on servers,   VMs or workstations to automatically record and upload employees' SSH sessions   to your asciinema server instance or other storage location. Ideal for training,   troubleshooting, and maintaining compliance.</li> <li>session live streaming: like above but with ability to watch sessions in   real-time, as they happen. Also great for training and presentations, allowing   for immediate feedback and collaboration.</li> <li>full text search: automatic scanning of recorded sessions for undesired   content like use of certain command-line tools or accidental exposure of   secrets.</li> <li>playback of custom recording formats: extending   asciinema player to allow replaying textual or binary log files.</li> <li>SSO for asciinema server: implementing Single Sign-On to ensure secure and convenient access to your   asciinema server instance. SAML, Google Workspace, Azure AD, Auth0, and more.</li> <li>CI/CD integration: embedding asciinema recorder in your CI/CD pipeline to make   debugging build failures easier. Possible thanks to additional timing   information session recording files bring over regular log files.</li> <li>bare-metal optimizations for Elixir/Erlang codebases: identifying slow parts,   rewriting them in Rust and integrating as NIFs (Rustler).</li> </ul>"},{"location":"consulting/#get-in-touch","title":"Get in touch","text":"<p>Don't hesitate to get in touch. Whether you're interested in a specific service or want to explore customization possibilities, you're invited to start the conversation.</p> <p>Send email to consulting@asciinema.orginema.org and we'll take it from there.</p>"},{"location":"donations/","title":"Donations","text":"<p>asciinema is free and open-source software. Sustainability of its development relies on donations and sponsorships. Please help the software project you use and love.</p> <p>Your support:</p> <ul> <li>allows asciinema lead developer, Marcin Kulik,   to spend more time on implementing requested features, fixing bugs and helping   the community,</li> <li>covers maintenance costs of running asciinema's main hosting site,   asciinema.org, such as servers, domains, DNS, backup   storage space, etc, keeping it free for everyone,</li> <li>grants you a \"Supporter\" badge on your asciinema.org user profile.</li> </ul>"},{"location":"donations/#individuals","title":"Individuals","text":"<p>To donate via Github Sponsors click the button below:</p> <p>   \u2764\ufe0f\u00a0\u00a0Donate </p> <p>To donate via Liberapay click the button below:</p> <p> </p> <p>Send Bitcoin to:</p> <p> bc1qcscjt6mm970rfglhj2l6c79ujy6jj3nsxmsfzz</p> <p>You can also reach out via donations@asciinema.orginema.org to discuss best funds transfer option.</p>"},{"location":"donations/#corporate-sponsorship","title":"Corporate sponsorship","text":"<p>If your company uses asciinema, either in a product or internally, please consider giving back by becoming a sponsor.</p> <p>Also, if your product's target audience overlaps with asciinema userbase (sysadmins/ops, developers), sponsoring the project lets you reach them by getting your logo/link on asciinema.org, in Github repositories, or on asciinema blog.</p> <p>Check out the sponsorship tiers by clicking the button below:</p> <p>   \u2764\ufe0f\u00a0\u00a0Sponsor </p> <p>Other than funding you can support the project by providing free services/resources like compute, storage, DNS, CDN, which could help lowering operational costs of running asciinema.org.</p> <p>For custom sponsorship deals reach out via donations@asciinema.orginema.org.</p> <p>Shout-out to asciinema's current sponsors:</p> <ul> <li>Brightbox</li> <li>DataDog</li> </ul>"},{"location":"donations/#consulting","title":"Consulting","text":"<p>Another way of supporting the project is to use consulting services offered by asciinema's lead developer. If asciinema doesn't support your use-case and you wish it did, consider this option. It's a win-win!</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>Here you can find answers to most frequently asked questions about asciinema.</p> <p>If you don't find an answer to your question join our Matrix room <code>#asciinema:matrix.org</code> (web client) or <code>#asciinema</code> IRC channel on Libera.Chat (web client).</p>"},{"location":"faq/#how-is-asciinema-pronounced","title":"How is \"asciinema\" pronounced?","text":"<p>[as-kee-nuh-muh].</p> <p>The word \"asciinema\" is a combination of English \"ASCII\" and Ancient Greek \"\u03ba\u03af\u03bd\u03b7\u03bc\u03b1\" (k\u00edn\u0113ma, \"movement\").</p>"},{"location":"faq/#what-kind-of-sorcery-is-this","title":"What kind of sorcery is this?","text":"<p>It's not a sorcery. Read about it on the How it works page.</p>"},{"location":"faq/#do-i-have-to-upload-my-recordings-to-asciinemaorg","title":"Do I have to upload my recordings to asciinema.org?","text":"<p>No.</p> <p>When you record with <code>asciinema rec &lt;filename&gt;</code> then the recording is saved locally, nothing is uploaded anywhere.</p> <p>You can replay it directly in your terminal with:</p> <pre><code>asciinema play &lt;filename&gt;\n</code></pre> <p>At this point you have several options if you want to share it.</p> <p>First, if you want to host it on asciinema.org in the end then run:</p> <pre><code>asciinema upload &lt;filename&gt;\n</code></pre> <p>You can view the recording there and share it via secret (default) or public URL.</p> <p>If you'd rather host it yourself you have following options:</p> <ul> <li>use standalone asciinema player on your website, or</li> <li>set up your own asciinema server instance instance,   and set API URL   accordingly.</li> </ul> <p>With older versions of asciinema CLI (2.x), when you run <code>asciinema rec</code> without specifying the filename argument then after completing the recording you get a prompt which lets you decide what to do.</p> <p>asciinema 2.4+ lets you decide whether to save, upload or discard the recording:</p> <pre><code>asciinema: recording finished\n(s)ave locally, (u)pload to asciinema.org, (d)iscard\n[s,u,d]? _\n</code></pre> <p>Versions prior to 2.4 let you confirm or cancel the upload:</p> <pre><code>asciinema: recording finished\nasciinema: press &lt;enter&gt; to upload to asciinema.org, &lt;ctrl-c&gt; to save locally\n_\n</code></pre>"},{"location":"faq/#how-can-i-delete-a-recording-from-asciinemaorg","title":"How can I delete a recording from asciinema.org?","text":"<p>In order to be able to delete a recording you first need to associate it with an asciinema.org user account. You can do that by using <code>asciinema auth</code> command (run <code>asciinema auth --help</code> for details). Once you complete this step look for a dropdown with a gear icon on recording page (it's below the player, on the right side).</p> <p>If you don't want to create an asciinema.org account only to delete a recording, you don't need to do anything. All recordings not associated with a user account are automatically deleted 7 days after they were uploaded.</p> <p>Note</p> <p>A new install ID is generated on each system you use asciinema on, so in order to keep all recordings under a single asciinema.org account you need to run <code>asciinema auth</code> on all of those systems.</p> <p>If you followed the above steps and you still can't see the gear dropdown then most likely you have used different local user accounts for recording and for auth (e.g. you recorded in a VM or Docker container but you ran <code>asciinema auth</code> on your host machine).</p>"},{"location":"faq/#can-i-editpost-process-the-recording","title":"Can I edit/post-process the recording?","text":"<p>Yes, but not yet in the way you would expect :)</p> <p>asciicasts are quite simple newline-delimited JSON files. You can edit them easily with any text editor which supports UTF-8. The recorded data is more or less a series of print statements, with ansi escape sequences (also known as control sequences or control codes). You can add, delete or modify text there. There's no tool for visual editing of the screen contents though (due to incremental, state-machine based nature of terminal emulators).</p>"},{"location":"faq/#does-asciinema-record-the-passwords-i-type-during-recording-sessions","title":"Does asciinema record the passwords I type during recording sessions?","text":"<p>By default asciinema records only terminal output - what you actually see in a terminal window. It doesn't record input, i.e. key presses.</p> <p>Some applications turn off so called \"echo mode\" when asking for a password, hiding the password.  Because the typed in password characters are not printed they're not recorded. Other applications display star characters instead of real characters and asciinema records only \"***\" (a bunch of stars). However, there are applications which don't have any precautions and the actual password is echoed to a terminal. In such case the password would be recorded by asciinema. Make sure you know how an application is handling password input before you record it.</p> <p>asciinema CLI 2.0 introduced ability to record key presses with <code>asciinema rec --stdin</code> option (now called <code>--capture-input</code> in CLI 3.x). When this option is used then all typed in characters are captured as stdin (i) events in the resulting asciicast file. This includes all passwords typed in from a keyboard, even if \"echo mode\" is turned off. When replaying, these chars are not displayed as output, but they could be used with asciinema player to implement custom event handler for input events.</p> <p><code>--capture-input</code> basically does keylogging that is scoped to a single shell instance / terminal tab. Given its sensitive nature it's disabled by default and has to be explicitly enabled (opted-in). However, even if enabled, captured key presses are saved in the local recording file only. Unless you publish your recording on the internet, e.g. on asciinema.org, it all stays with you.</p>"},{"location":"faq/#why-am-i-getting-command-not-found-at-the-beginning-of-the-recording-session","title":"Why am I getting <code>command not found</code> at the beginning of the recording session?","text":"<p>When you record your terminal asciinema starts a new shell instance (as indicated by <code>$SHELL</code> environment variable) by default. It invokes <code>exec $SHELL</code>, which in most cases translates to <code>exec /bin/bash</code> or <code>exec /bin/zsh</code>. This means the shell runs as an \"interactive shell\", but not as a \"login shell\".</p> <p>If you have functions and/or other shell configuration defined in either <code>.bash_profile</code>, <code>.zprofile</code> or <code>.profile</code> file they are not loaded unless the shell is started as a login shell.</p> <p>Some terminal emulators do that (passing \"-l\" option to the shell command-line), some don't. asciinema doesn't.</p> <p>Worry not, you have several options. You can:</p> <ul> <li>move this part of configuration to <code>.bashrc/.zshrc</code>,</li> <li>record with <code>asciinema rec -c \"/bin/bash -l\"</code> or,</li> <li>add the following setting to your <code>$HOME/.config/asciinema/config</code> file:</li> </ul> <pre><code>[record]\ncommand = /bin/bash -l\n</code></pre>"},{"location":"faq/#how-can-i-change-my-asciinemaorg-profile-avatar","title":"How can I change my asciinema.org profile avatar?","text":"<p>asciinema.org (any asciinema server in general) uses gravatar.com for profile avatars. The avatars are based on account email address.</p> <p>If you want to change yours then you can do it at gravatar.com.</p> <p>At the moment this is the only option.</p>"},{"location":"faq/#why-my-shell-prompttheme-isnt-working-during-recording","title":"Why my shell prompt/theme isn't working during recording?","text":"<p>See this answer.</p>"},{"location":"faq/#why-upload-failed-invalid-or-revoked-install-id","title":"Why <code>upload failed: Invalid or revoked install ID</code>?","text":"<p>If you get this error when uploading a recording then it means your local install ID has been revoked (you most likely clicked \"Revoke\" on your account settings page). No further uploads with this install ID will be possible.</p> <p>To re-enable uploads from this machine do this:</p> <ol> <li>remove the install ID file <code>~/.config/asciinema/install-id</code> (also check <code>~/.asciinema/install-id</code>)</li> <li>login to your asciinema.org account</li> <li>run <code>asciinema auth</code> - this will generate new local install ID</li> <li>open the printed URL - this will re-authenticate your system with you asciinema.org account</li> </ol>"},{"location":"faq/#why-some-of-my-custom-shell-functions-are-not-available-during-recording","title":"Why some of my custom shell functions are not available during recording?","text":"<p>See this answer.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide serves as your introduction to asciinema, starting with the basics of recording a terminal with asciinema CLI. We'll cover how to share recordings via asciinema.org, live stream terminal sessions, embed asciinema player on a website, and conclude with instructions for self-hosting asciinema server.</p>"},{"location":"getting-started/#recording","title":"Recording","text":"<p>Install the asciinema CLI first. There are several installation options to choose from:</p> Download static binaryapt (Debian, Ubuntu)pacman (Arch, Manjaro)homebrew (macOS)pipx (asciinema 2.4 only)Other <p>You can download a pre-built, static binary of the latest version from the releases page.</p> <pre><code>sudo apt install asciinema\n</code></pre> <pre><code>sudo pacman -S asciinema\n</code></pre> <pre><code>brew install asciinema\n</code></pre> <pre><code>pipx install asciinema\n</code></pre> <p>Check the Installation section for all installation options.</p> <p>Now record your terminal with:</p> <pre><code>asciinema rec demo.cast\n</code></pre> <p>This starts a new recording session, where everything printed to a terminal gets captured and saved to the <code>demo.cast</code> file in asciicast format.</p> <p>To end the recording session simply exit the shell. This can be done by pressing ctrl+d or entering <code>exit</code>.</p> <p>Replay your recording with:</p> <pre><code>asciinema play demo.cast\n</code></pre> <p>You can pause/resume by pressing space, or end the playback early by pressing ctrl+c.</p> <p>See asciinema CLI quick-start guide for more examples.</p>"},{"location":"getting-started/#sharing","title":"Sharing","text":"<p>Replaying a recording in your terminal is handy but not as useful as sharing it with the wider audience on the internet.</p> <p>You can host your recordings at asciinema.org, which is a public asciinema server instance that provides free hosting for terminal recordings. Hosting your recordings on asciinema.org is completely optional but has many benefits, e.g. easy sharing and embedding.</p> <p>Upload your recording to asciinema.org with:</p> <pre><code>asciinema upload demo.cast\n</code></pre> <p>The command prints a secret link to the recording page, where you can view it. Feel free to share the link with anyone.</p> <p>The player component on the recording page is not a typical video player. It's asciinema player, built from the ground up to play terminal sessions. It lets you copy the contents of its terminal view, just like in a regular terminal. Try it: pause the playback, select some lines, copy, paste elsewhere. It's just text after all!</p> <p>If you'd like to manage your recordings on asciinema.org (set a title, change terminal color theme) you need to link your uploads to your asciinema.org user account. To do it run:</p> <pre><code>asciinema auth\n</code></pre> <p>This command displays a URL, which, when opened in a web browser, authenticates the CLI with your asciinema.org account, ensuring you have access to your uploads.</p> <p>You can skip this step now, and do it later. However, all recordings not assigned to an account are automatically deleted after 7 days. Run <code>asciinema upload --help</code> and <code>asciinema auth --help</code> for detailed information.</p>"},{"location":"getting-started/#live-streaming","title":"Live streaming","text":"<p>In addition to recording terminal sessions to a file, asciinema also supports terminal live streaming. This is useful for live coding sessions, visual monitoring of servers (e.g. with <code>htop</code>), etc.</p> <p>To start a live stream to asciinema.org:</p> <pre><code>asciinema stream -r\n</code></pre> <p>This provides you with a URL that viewers can visit to watch your terminal session in real-time. The stream begins immediately and continues until you end the session by pressing ctrl+d or entering <code>exit</code>.</p> <p>This mode of streaming is called \"remote streaming\", as it sends the stream to a remote asciinema server, which acts as a (public) relay. Remote streaming works with any self-hosted asciinema server, not just asciinema.org.</p> <p>There's also local streaming mode:</p> <pre><code>asciinema stream -l\n</code></pre> <p>This starts a local web server that lets you access the live stream from your local machine or over LAN. This is purely local, \"no-cloud\" mode, and no data is sent anywhere.</p> <p>Run <code>asciinema stream --help</code> for more streaming options. Check out the server streaming guide for technical details about the streaming protocols.</p> <p>Note</p> <p>Live streaming requires asciinema CLI 3.0 or newer.</p>"},{"location":"getting-started/#embedding","title":"Embedding","text":"<p>asciinema player can be embedded on any website by using HTML <code>&lt;script&gt;</code> tag. Embedded player is commonly used on blogs, in project documentation, and in conference talk slides.</p> <p>All recordings uploaded to asciinema.org can be embedded on a website by using a script snippet provided on the recording's page. It looks like this:</p> <pre><code>&lt;script async id=\"asciicast-569727\" src=\"https://asciinema.org/a/569727.js\"&gt;&lt;/script&gt;\n</code></pre> <p>To get it, go to a recording page, click on the \"Share\" button and copy the script from the \"Embed the player\" section.</p> <p>The above <code>&lt;script&gt;</code> tag is included right below this very paragraph, resulting in the following player:</p> <p>If you prefer not to rely on asciinema.org for your embedded demos, you can use the standalone player on your website like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  ...\n  &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/asciinema-player.css\" /&gt;\n  ...\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n  &lt;div id=\"demo\"&gt;&lt;/div&gt;\n  ...\n  &lt;script src=\"/asciinema-player.min.js\"&gt;&lt;/script&gt;\n  &lt;script&gt;\n    AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'));\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>See asciinema player quick-start guide for full setup details.</p>"},{"location":"getting-started/#self-hosting-the-server","title":"Self-hosting the server","text":"<p>While asciinema.org is the default asciinema server used by the CLI for uploading recordings, you can self-host your own instance if you want full ownership and control over the recordings.</p> <p>asciinema server is packaged as OCI container image and is available at ghcr.io/asciinema/asciinema-server.</p> <p>Here's a minimal docker-compose example:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    image: ghcr.io/asciinema/asciinema-server:latest\n    ports:\n      - '4000:4000'\n    volumes:\n      - asciinema_data:/var/lib/asciinema\n    depends_on:\n      postgres:\n        condition: service_healthy\n\n  postgres:\n    image: docker.io/library/postgres:14\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_HOST_AUTH_METHOD=trust\n    healthcheck:\n      test: ['CMD-SHELL', 'pg_isready -U postgres']\n      interval: 2s\n      timeout: 5s\n      retries: 10\n\nvolumes:\n  asciinema_data:\n  postgres_data:\n</code></pre> <p>Start it with:</p> <pre><code>docker compose up\n</code></pre> <p>Then point asciinema CLI to it by setting <code>ASCIINEMA_API_URL</code> environment variable:</p> <pre><code>export ASCIINEMA_API_URL=http://localhost:4000\n\nasciinema rec demo.cast\nasciinema upload demo.cast\n</code></pre> <p>Note that the above configuration should be used only for testing the server locally. See full server self-hosting guide to learn how to set it up properly in a full-featured and secure way.</p>"},{"location":"getting-started/#generating-a-gif","title":"Generating a GIF","text":"<p>On websites where <code>&lt;script&gt;</code> tags are not allowed but <code>&lt;img&gt;</code> tags are, you can use animated GIF files for embedding your demos.</p> <p>Use agg to create a GIF file from your recording:</p> <pre><code>agg demo.cast first.gif\n</code></pre> <p>See agg usage manual for GIF generation details.</p> <p>Using asciinema player to present a recording is usually a better choice than a GIF file if you have the option of using <code>&lt;script&gt;</code> tags. Contrary to GIF, the player provides the ability to pause, rewind, copy text, and it always renders the terminal content as sharp as possible on a given display.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<p>Thank you for taking the first steps with asciinema through this introductory guide. Our goal was to provide you with a clear, high-level overview of the asciinema tools and their usage.</p> <p>For additional insights and answers, feel free to explore our FAQ section and join the conversation in the <code>#asciinema</code> room on the Matrix network, <code>#asciinema:matrix.org</code> (web client), or <code>#asciinema</code> IRC channel on Libera.Chat (web client).</p> <p>To stay updated on the latest developments and get useful tips, follow @asciinema@fosstodon.org on Mastodon.</p> <p>Happy recording!</p>"},{"location":"history/","title":"History","text":"<p>The asciinema project was started by Marcin Kulik in 2011.</p> <p>While Marcin had been playing with the idea of sharing terminal session recordings on the web since 2010, the working prototype of what eventually became asciinema came to life a bit later.</p> <p>Initially, all components of asciinema - asciinema CLI (the recorder), asciinema player, and asciinema server - were developed as parts of a single Ruby on Rails codebase. The recorder was a simple, single-file Python program. The player was a single JavaScript file with an ad-hoc, incomplete parser for ANSI escape sequences, using jQuery to juggle the lines of a fake terminal view in a web browser. It was rough but worked well enough to deserve continued development.</p> <p>The project was initially named \"ascii.io\". In March 2012, the ascii.io site was launched, providing free hosting for terminal session recordings made with the <code>asciiio</code> script (triple \"i\", omg!). The project was renamed to \"asciinema\" in September 2013 and published as asciinema package to PyPI around the same time.</p> <p>In late 2014, the recorder was rewritten in Go, preserving the functionality of the previous versions while improving in some areas. The first release of the new codebase was 0.9.9, published in December 2014.</p> <p>The same year, version 1.0 of the player came out, quickly followed by version 1.0 of the recorder, which was released in March 2015. These releases stabilized the first version of asciinema's recording file format, asciicast v1.</p> <p>Version 1.2 of the recorder was the final version implemented in Go. For several reasons, it was reverted to the previous Python implementation. The new-old recorder was released in July 2016 as version 1.3, with all new features backported from the Go codebase.</p> <p>The lack of a proper ANSI parser in the early versions of the asciinema player was an obstacle to timely bug fixes and more comprehensive terminal emulation. Therefore, in 2015, work started on implementing a new version of the player with a proper ANSI-compatible terminal parser embedded. The result was asciinema player 2.0, rewritten from scratch in ClojureScript, and released in January 2016.</p> <p>In 2017, the asciinema server was rewritten in Elixir and Phoenix. Around the same time, it was also made more self-hosting-friendly, with updated installation docs and a simplified setup in containerized environments.</p> <p>February 2018 marked the release of asciinema recorder 2.0, which introduced an improved recording file format, asciicast v2, among many new features.</p> <p>Another milestone was achieved in May 2022 with the release of asciinema player 3.0, in which the terminal emulation part was implemented in Rust (as the avt library) and compiled to WebAssembly, resulting in a 4x smaller, 50x faster player.</p> <p>Outside of asciinema's core components, a new, ultra-fast asciinema GIF generator, agg, was released in August 2022. The creation of agg was, to a degree, sparked by avt. In fact, avt has also been integrated into the asciinema server, where it's used for thumbnail generation and recording analysis since 2020.</p> <p>The final version of the asciinema CLI 2.x line, 2.4, was released in October 2023. This was the last version built with Python.</p> <p>In September 2025 the brand new CLI 3.0 has been released, which was a complete rewrite in Rust, upgrading the recording file format to asciicast v3, introducing terminal live streaming, and bringing numerous improvements across the board.</p>"},{"location":"how-it-works/","title":"How it works","text":"<p>Unlike traditional screen recording tools that capture video, asciinema captures the textual output, making the recording files and terminal live streams very lightweight and easy to share.</p> <p>asciinema's recording process is deeply rooted in the Unix pseudo-terminal (PTY) concept, a mechanism shared by commands like <code>ssh</code>, <code>screen</code>, and <code>script</code>. A PTY is essentially a pair of pseudo-devices: the slave, which emulates a real text terminal, and the master, which a terminal emulator process uses to control the slave.</p> <p>Whether you record with <code>asciinema rec &lt;filename&gt;</code> or stream with <code>asciinema stream</code>, asciinema acts as the master, interfacing between the user and the shell. This setup allows asciinema to transparently capture all terminal outputs, including text and invisible escape/control sequences, in their raw, unfiltered form. Additionally, the use of PTY lets asciinema capture terminal window resize events, and when enabled, also keyboard input.</p> <p>When recording with <code>asciinema rec</code>, the recordings are saved in asciicast format, designed for simplicity and interoperability. Every detail of the terminal session is encoded as a sequence of time-stamped events, preserving not only the content but also the rhythm and flow of the session. Similarly, when streaming with <code>asciinema stream</code>, the session live stream is transmitted to the viewers in real-time using lightweight, WebSocket-based streaming protocol, which ensures minimal latency and perfect fidelity.</p> <p>Displaying a captured session involves more than just displaying text; it requires interpreting a complex series of ANSI escape code sequences to accurately render what was captured. When you replay in a terminal, with <code>asciinema play &lt;filename&gt;</code>, your terminal does the job of interpreting and rendering the recorded content. asciinema simply leverages the terminal to do the heavy lifting.</p> <p>However, playback in a web browser is another story. To do that we need something that can interpret ANSI sequences and produce visual representation of a terminal window. Therefore, asciinema player is powered by a bespoke terminal emulator, avt, based on Paul Williams' parser for ANSI-compatible video terminals. This emulator is specifically tailored to replicate the display aspect of terminal emulation, handling color changes, cursor movements, and accurate placement of text on the screen. It ensures that all text attributes, including color, and styles like bold, underline, inverse, are perfectly rendered, creating a faithful viewing experience.</p> <p>For implementation details check out asciinema CLI source code, asciinema server source code and asciinema player source code.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>There are many tools and integrations built for asciinema. Below is a selection of cool things out there (in alphabetical order):</p> <ul> <li>ansible-role-asciinema - Ansible role for asciinema</li> <li>asciifx - A special effects shop for asciinema</li> <li>asciinema-comment - Edit an asciinema cast to insert subtitles</li> <li>asciinema-director - A way to record your terminal using asciinema like a pro</li> <li>asciinema-edit - asciinema casts post-production tools</li> <li>asciinema-mp4 - Render high quality terminal output using asciinema and Remotion</li> <li>asciinema-player-for-github - Browser extension to automatically detect asciinema links in a README and embed the asciinema player in its place</li> <li>asciinema-player-vue - Vue.js integration for asciinema-player</li> <li>asciinema-scenario - Create asciinema videos from a text file</li> <li>asciinema-scene - Toolbox to edit asciinema screencasts</li> <li>asciinema-trim - Trim and change the playback speed of asciinema's session</li> <li>asciinema-vsync - Batch the commands inside an asciinema JSON file to reduce flickering</li> <li>AsciinemaGenerator.jl - Generate asciinema <code>.cast</code> file from a Julia script</li> <li>autocast - Automate terminal demos</li> <li>autorecorder - An automatic declarative asciinema recorder</li> <li>awesome-ttygames - Unix ASCII games</li> <li>ember-asciinema-player - asciinema player for Ember</li> <li>gohugo-asciinema - Insert the asciinema player in your Hugo site with ease</li> <li>google-slides-asciinema - A Chrome extension to embed asciinema animations in your Google Slides</li> <li>jekyll-asciinema - Liquid tag for embedding asciicasts recorded with asciinema for use in Jekyll sites</li> <li>mini-asciinema-store - Small server for storing asciinema recordings</li> <li>movee - Script bash and Python into asciinema movies</li> <li>obsidian-asciinema-player - Obsidian plugin which supports embedding asciicast files into Markdown files</li> <li>slidev-addon-asciinema - Slidev addon to embed asciinema casts to presentations</li> <li>sphinxcontrib.asciinema - Easily embed asciinema videos into Sphinx documentation</li> <li>spielbash - Spielbash helps you to automate asciicasts with asciinema</li> <li>svg-term-cli - Share terminal sessions via SVG and CSS</li> <li>terminal-demo - Produce GIFs from shell commands</li> <li>wp-asciinema - A WordPress plugin to allow for self-hosted asciicasts created with asciinema</li> </ul> <p>To add your own project here edit this file and create a pull request.</p>"},{"location":"manual/","title":"Manual","text":"<p>Welcome to the asciinema manual!</p> <p>If you're new to asciinema then make sure to go through the getting started guide first, which gives a high-level overview of the functionality, then come back here.</p> <ul> <li>asciinema CLI - learn how to use full potential of asciinema CLI for recording, live streaming, and publishing your terminal sessions</li> <li>asciinema player - learn how to use asciinema's standalone web player to include a terminal recording on your own website</li> <li>asciinema server - learn how to use asciinema.org's embedding options, and how to easily self-host an asciinema server</li> <li>asciinema gif generator - learn how to transform your terminal session recordings into attractive, animated GIF files</li> </ul>"},{"location":"manual/agg/","title":"agg - asciinema gif generator","text":"<p>agg is a command-line tool for generating animated GIF files from terminal session recordings.</p> <p>It supports conversion from asciicast v2 files produced by asciinema recorder. It uses Kornel Lesi\u0144ski's excellent gifski library to produce optimized, high quality GIF output with accurate frame timing.</p> <p>Example GIF file generated with agg:</p> <p></p> <p>Notable features:</p> <ul> <li>creating GIFs from local <code>.cast</code> files as well as from recordings hosted at   asciinema.org,</li> <li>multiple built-in color themes, ability to use a custom theme,</li> <li>font family and font size customization,</li> <li>adjustable animation speed,</li> <li>emoji support.</li> </ul> <p>agg is free and open-source software (FOSS). Source code and license available at github.com/asciinema/agg.</p>"},{"location":"manual/agg/installation/","title":"Installation","text":""},{"location":"manual/agg/installation/#native-package","title":"Native package","text":"<p>agg may be available in your operating system's packager manager repository. Search for <code>agg</code> or <code>asciinema-agg</code>.</p> <p>If it's not there then you can download prebuilt agg binary or build from source.</p>"},{"location":"manual/agg/installation/#prebuilt-binaries","title":"Prebuilt binaries","text":"<p>agg is written in Rust, and Rust compiler produces standalone binaries that can run without extra dependencies. There's Github Actions Release workflow for agg which builds binaries for multiple OSes and CPU architectures, attaching the binaries to every new release on Github.</p> <p>Visit latest release page, and download a binary appropriate for your system.</p> <p>For 64-bit x86 system choose a file with <code>x86_64</code> in the name. For ARMv8 (64-bit, e.g. Apple Silicon) choose a file with <code>aarch64</code>. For ARMv7 (32-bit, e.g. Raspberry Pi) choose a file with <code>arm</code>.</p> <p>Make it executable and put it somewhere in <code>$PATH</code>:</p> <pre><code>chmod a+x agg\nsudo mv agg /usr/local/bin\n</code></pre>"},{"location":"manual/agg/installation/#building-from-source","title":"Building from source","text":"<p>Building from source requires Rust compiler (1.56.0 or later) and Cargo package manager. You can install both with rustup.</p> <p>To download source code, build agg binary and install it in <code>$HOME/.cargo/bin</code> run:</p> <pre><code>cargo install --git https://github.com/asciinema/agg\n</code></pre> <p>You need to ensure <code>$HOME/.cargo/bin</code> is in your shell's <code>$PATH</code>.</p> <p>Alternatively, you can manually download source code and build agg binary with:</p> <pre><code>git clone https://github.com/asciinema/agg\ncd agg\ncargo build --release\n</code></pre> <p>This produces an executable file in release mode (<code>--release</code>) at <code>target/release/agg</code>. There are no other build artifacts so you can copy the binary to a directory in your <code>$PATH</code>.</p>"},{"location":"manual/agg/installation/#building-with-docker","title":"Building with Docker","text":"<p>Alternatively, if you have Docker, Podman or another Docker-compatible tool installed you can use it to build agg container image. This doesn't require Rust toolchain installed on your machine.</p> <p>Build the image with the following command:</p> <pre><code>docker build -t agg .\n</code></pre> <p>Then run agg like this:</p> <pre><code>docker run --rm -it -u $(id -u):$(id -g) -v $PWD:/data agg demo.cast demo.gif\n</code></pre> <p>If you use Podman in root-less mode:</p> <pre><code>podman run --rm -it -v $PWD:/data agg demo.cast demo.gif\n</code></pre>"},{"location":"manual/agg/usage/","title":"Usage","text":""},{"location":"manual/agg/usage/#basic-usage","title":"Basic usage","text":"<pre><code>agg demo.cast demo.gif\n</code></pre> <p>The above command renders a GIF file with default theme (dracula), font size 14px.</p> <p>You can also provide an asciinema.org URL as the first argument:</p> <pre><code>agg https://asciinema.org/a/569727 starwars.gif\n</code></pre> <p>Additional options are available for customization. For example, the following command selects Monokai theme, larger font size, 2x playback speed:</p> <pre><code>agg --theme monokai --font-size 20 --speed 2 demo.cast demo.gif\n</code></pre> <p>Run <code>agg -h</code> to see all available options.</p>"},{"location":"manual/agg/usage/#fonts","title":"Fonts","text":"<p>By default agg uses common monospaced font for a given platform, that can be found on its default font family list. The list includes DejaVu Sans Mono and Liberation Mono (found on most Linux distros), SF Mono and Menlo (found on macOS), Consolas (found on Windows), with addition of my personal favourites like JetBrains Mono and Fira Code. The fonts are not included in agg and must be present on the system. To see the default value run <code>agg --help</code> and look for <code>--font-family</code>. In addition there's implicit fallback to DejaVu Sans (not Mono) which helps with rendering symbols like \u28fd or \u2714 amongst others.</p> <p>If you want to use another font family then pass a comma-separated list like this:</p> <pre><code>agg --font-family \"Source Code Pro,Fira Code\" demo.cast demo.gif\n</code></pre> <p>As long as the fonts you want to use are installed in one of standard system locations (e.g. /usr/share/fonts or ~/.local/share/fonts on Linux) agg will find them. You can also use <code>--font-dir=/path/to/fonts</code> option to include extra fonts. <code>--font-dir</code> can be specified multiple times.</p> <p>To verify agg picks up your font run it with <code>-v</code> (verbose) flag:</p> <pre><code>agg -v --font-family \"Source Code Pro,Fira Code\" demo.cast demo.gif\n</code></pre> <p>It should print something similar to:</p> <pre><code>[INFO agg] selected font families: [\"Source Code Pro\", \"Fira Code\", \"DejaVu Sans\", \"Noto Emoji\"]\n</code></pre> <p>This list may also include implicit addition of DejaVu Sans fallback (mentioned earlier), as well as Noto Emoji (see section below).</p> <p>Here's how to use Nerd Fonts with agg:</p> <ol> <li>Download one of the patched font sets from    https://github.com/ryanoasis/nerd-fonts/releases/latest , e.g. JetBrainsMono.zip</li> <li>Unzip them into <code>~/.local/share/fonts</code> (on Linux) or install with system font    manager (macOS, Windows)</li> <li>Specify font family like this:</li> </ol> <pre><code>agg --font-family \"JetBrainsMono Nerd Font Mono\" demo.cast demo.gif\n</code></pre>"},{"location":"manual/agg/usage/#emoji","title":"Emoji","text":"<p>agg supports emojis when either Noto Color Emoji or Noto Emoji font is installed. The default renderer, <code>resvg</code>, supports color emojis, while <code>fontdue</code> renderer only supports monochrome emojis.</p> <p>Install Noto Emoji font on your system or, point agg to a folder containing <code>NotoColorEmoji.ttf</code> or <code>NotoEmoji-*.ttf</code> files with <code>--font-dir</code>.</p>"},{"location":"manual/agg/usage/#color-themes","title":"Color themes","text":"<p>There are several built-in color themes you can use with <code>--theme</code> option:</p> <ul> <li>asciinema</li> <li>dracula (default)</li> <li>monokai</li> <li>solarized-dark</li> <li>solarized-light</li> </ul> <p>If your asciicast file includes theme definition then it's used automatically unless <code>--theme</code> option is explicitly specified.</p> <p>A custom, ad-hoc theme can be used with <code>--theme</code> option by passing a series of comma-separated hex triplets defining terminal background color, default text color and a color palette:</p> <pre><code>--theme bbbbbb,ffffff,000000,111111,222222,333333,444444,555555,666666,777777\n</code></pre> <p>The above sets terminal background color to <code>bbbbbb</code>, default text color to <code>ffffff</code>, and uses remaining 8 colors as SGR color palette.</p> <p>Additional bright color variants can be specified by adding 8 more hex triplets at the end. For example, the equivalent of the built-in Monokai theme is:</p> <pre><code>--theme 272822,f8f8f2,272822,f92672,a6e22e,f4bf75,66d9ef,ae81ff,a1efe4,f8f8f2,75715e,f92672,a6e22e,f4bf75,66d9ef,ae81ff,a1efe4,f9f8f5\n</code></pre>"},{"location":"manual/agg/usage/#gif-optimization","title":"GIF optimization","text":"<p>GIF encoder used by agg, gifski, produces great looking GIF files, although this often comes at a cost - file size.</p> <p>gifsicle can be used to shrink the produced GIF file:</p> <pre><code>gifsicle --lossy=80 -k 128 -O2 -Okeep-empty demo.gif -o demo-opt.gif\n</code></pre> <p>Every recording is different so you may need to tweak the lossiness level (<code>--lossy</code>), number of colors (<code>-k</code>) and other options to suit your needs.</p>"},{"location":"manual/asciicast/v1/","title":"asciicast v1","text":"<p>asciicast v1 is a file format for terminal sessions recorded by asciinema CLI 1.x.</p> <p>It's based on JSON.</p> <p>The format describes terminal metadata, such as initial terminal size, timestamp, etc, and a list of timed output (terminal write) events that were captured during recording session.</p> <p>asciicast v1 file looks like this:</p> <pre><code>{\n  \"version\": 1,\n  \"width\": 80,\n  \"height\": 24,\n  \"duration\": 1.515658,\n  \"command\": \"/bin/zsh\",\n  \"title\": \"\",\n  \"env\": {\n    \"TERM\": \"xterm-256color\",\n    \"SHELL\": \"/bin/zsh\"\n  },\n  \"stdout\": [\n    [\n      0.248848,\n      \"\\u001b[1;31mHello \\u001b[32mWorld!\\u001b[0m\\n\"\n    ],\n    [\n      1.001376,\n      \"I am \\rThis is on the next line.\"\n    ]\n  ]\n}\n</code></pre>"},{"location":"manual/asciicast/v1/#attributes","title":"Attributes","text":"<p>Every asciicast v1 includes the following set of attributes:</p> <ul> <li><code>version</code> - must be set to 1,</li> <li><code>width</code> - terminal width, i.e. number of columns,</li> <li><code>height</code> - terminal height, i.e. number of rows,</li> <li><code>duration</code> - total duration of the recording, as a floating point number,</li> <li><code>command</code> - recorded command, as given via <code>-c</code> option to <code>rec</code>, optional,</li> <li><code>title</code> - title of the recording, as given via <code>-t</code> option to <code>rec</code>, optional,</li> <li><code>env</code> - map of environment variables, usually includes <code>TERM</code> and <code>SHELL</code>,</li> <li><code>stdout</code> - array of \"frames\", see below.</li> </ul>"},{"location":"manual/asciicast/v1/#frames","title":"Frames","text":"<p>Frame represents an event of printing new data to a terminal. It is a 2 element array containing delay and data.</p> <p>Delay is the number of seconds that elapsed since the previous frame (or since the beginning of the recording in case of the 1st frame) represented as a floating point number, with microsecond precision.</p> <p>Data is a string containing the data that was printed to a terminal in a given frame. It has to be valid, UTF-8 encoded JSON string as described in JSON RFC section 2.5, with all non-printable Unicode codepoints encoded as <code>\\uXXXX</code>.</p> <p>For example, frame <code>[5.4321, \"foo\\rbar\\u0007...\"]</code> means there was 5 seconds of inactivity between previous output and <code>foo\\rbar\\u0007...</code>.</p>"},{"location":"manual/asciicast/v2/","title":"asciicast v2","text":"<p>asciicast v2 is a file format for terminal sessions recorded by asciinema CLI 2.x.</p> <p>It's based on newline-delimited JSON.</p> <p>First line, encoded as JSON object, represents the header, which contains metadata, such as initial terminal size, timestamp, etc.</p> <p>All following lines form the event stream. Each line represents a separate event, encoded as 3-element JSON array.</p> <p>asciicast v2 file looks like this:</p> <pre><code>{\"version\": 2, \"width\": 80, \"height\": 24, \"timestamp\": 1504467315, \"title\": \"Demo\", \"env\": {\"TERM\": \"xterm-256color\", \"SHELL\": \"/bin/zsh\"}}\n[0.248848, \"o\", \"\\u001b[1;31mHello \\u001b[32mWorld!\\u001b[0m\\n\"]\n[1.001376, \"o\", \"That was ok\\rThis is better.\"]\n[1.500000, \"m\", \"\"]\n[2.143733, \"o\", \"Now... \"]\n[4.050000, \"r\", \"80x24\"]\n[6.541828, \"o\", \"Bye!\"]\n</code></pre>"},{"location":"manual/asciicast/v2/#header","title":"Header","text":"<p>asciicast header is JSON-encoded object containing recording metadata.</p> <p>Complete header example, pretty formatted for readability:</p> <pre><code>{\n  \"version\": 2,\n  \"width\": 80,\n  \"height\": 24,\n  \"timestamp\": 1504467315,\n  \"duration\": 123.45,\n  \"command\": \"/bin/bash\",\n  \"title\": \"Demo\",\n  \"idle_time_limit\": 2,\n  \"env\": {\n    \"SHELL\": \"/bin/bash\",\n    \"TERM\": \"xterm-256color\"\n  },\n  \"theme\": {\n    \"fg\": \"#d0d0d0\",\n    \"bg\": \"#212121\",\n    \"palette\": \"#151515:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#d0d0d0:#505050:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#f5f5f5\"\n  }\n}\n</code></pre> <p>Minimal header example:</p> <pre><code>{\"version\": 2, \"width\": 80, \"height\": 24}\n</code></pre>"},{"location":"manual/asciicast/v2/#required-header-attributes","title":"Required header attributes:","text":""},{"location":"manual/asciicast/v2/#version","title":"<code>version</code>","text":"<p>Format version number. Must be set to <code>2</code>. Integer.</p>"},{"location":"manual/asciicast/v2/#width","title":"<code>width</code>","text":"<p>Terminal width, i.e. number of columns. Integer.</p>"},{"location":"manual/asciicast/v2/#height","title":"<code>height</code>","text":"<p>Terminal height, i.e. number of rows. Integer.</p>"},{"location":"manual/asciicast/v2/#optional-header-attributes","title":"Optional header attributes:","text":""},{"location":"manual/asciicast/v2/#timestamp","title":"<code>timestamp</code>","text":"<p>Unix timestamp of the beginning of the recording session. Integer.</p>"},{"location":"manual/asciicast/v2/#duration","title":"<code>duration</code>","text":"<p>Duration of the whole recording in seconds (when it's known upfront). Float.</p>"},{"location":"manual/asciicast/v2/#idle_time_limit","title":"<code>idle_time_limit</code>","text":"<p>Idle time limit, as given via <code>-i</code> option to <code>asciinema rec</code>. Float.</p> <p>This should be used by an asciicast player to reduce all terminal inactivity (delays between frames) to a maximum of <code>idle_time_limit</code> value.</p>"},{"location":"manual/asciicast/v2/#command","title":"<code>command</code>","text":"<p>Command that was recorded, as given via <code>-c</code> option to <code>asciinema rec</code>. String.</p>"},{"location":"manual/asciicast/v2/#title","title":"<code>title</code>","text":"<p>Title of the recording, as given via <code>-t</code> option to <code>asciinema rec</code>. String.</p>"},{"location":"manual/asciicast/v2/#env","title":"<code>env</code>","text":"<p>A map of captured environment variables. Object (String -&gt; String).</p> <p>Example env:</p> <pre><code>{\"SHELL\": \"/bin/bash\", \"TERM\": \"xterm-256color\"}\n</code></pre> <p>Official asciinema recorder captures only <code>SHELL</code> and <code>TERM</code> by default. All implementations of asciicast-compatible terminal recorder should not capture any additional environment variables unless explicitly requested by the user.</p>"},{"location":"manual/asciicast/v2/#theme","title":"<code>theme</code>","text":"<p>Color theme of the recorded terminal. Object, with the following attributes:</p> <ul> <li><code>fg</code> - normal text color,</li> <li><code>bg</code> - normal background color,</li> <li><code>palette</code> - list of 8 or 16 colors, separated by colon character.</li> </ul> <p>All colors are in the CSS <code>#rrggbb</code> format.</p> <p>Example theme, pretty formatted for readability:</p> <pre><code>{\n  \"fg\": \"#d0d0d0\",\n  \"bg\": \"#212121\",\n  \"palette\": \"#151515:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#d0d0d0:#505050:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#f5f5f5\"\n}\n</code></pre> <p>Note</p> <p>asciinema CLI captures the original terminal theme automatically (since v3.0).</p> <p>If you're implementing an asciicast-compatible recorder, then you can retrieve the colors from the terminal via OSC sequences (this is how asciinema recorder does it). However, you can also use another technique, such as using <code>xrdb</code> (on Linux).</p>"},{"location":"manual/asciicast/v2/#event-stream","title":"Event stream","text":"<p>Each element of the event stream is a 3-tuple encoded as JSON array:</p> <pre><code>[time, code, data]\n</code></pre> <p>Where:</p> <ul> <li><code>time</code> (float) - time since the beginning of the recording session (in seconds),</li> <li><code>code</code> (string) - event type code, one of: <code>\"o\"</code>, <code>\"i\"</code>, <code>\"m\"</code>, <code>\"r\"</code></li> <li><code>data</code> (any) - event specific data, described separately for each event   code.</li> </ul> <p>For example, let's look at the following line:</p> <pre><code>[1.001376, \"o\", \"Hello world\"]\n</code></pre> <p>It represents:</p> <ul> <li>output (code <code>o</code>),</li> <li>of text <code>Hello world</code>,</li> <li>which happened <code>1.001376</code> sec after the start of the recording session.</li> </ul>"},{"location":"manual/asciicast/v2/#supported-event-codes","title":"Supported event codes","text":"<p>This section describes the event codes supported in asciicast v2 format.</p> <p>The list is open to extension, and new event codes may be added in both the current and future versions of the format. For example, we may add new event code for text overlay (subtitles display).</p> <p>A tool which interprets the event stream (web/cli player, post-processor) should ignore (or pass through) event codes it doesn't understand or doesn't care about.</p>"},{"location":"manual/asciicast/v2/#o-output-data-written-to-a-terminal","title":"o - output, data written to a terminal","text":"<p>Event with code <code>\"o\"</code> represents printing new data to a terminal.</p> <p><code>data</code> is a string containing the data that was printed. It must be valid, UTF-8 encoded JSON string as described in JSON RFC section 2.5, with any non-printable Unicode codepoints encoded as <code>\\uXXXX</code>.</p> <p>Example:</p> <pre><code>[5.0, \"o\", \"hello\"]\n</code></pre>"},{"location":"manual/asciicast/v2/#i-input-data-read-from-a-terminal","title":"i - input, data read from a terminal","text":"<p>Event with code <code>\"i\"</code> represents character typed in by the user, or more specifically, raw data sent from a terminal emulator to stdin of the recorded program (usually shell).</p> <p><code>data</code> is a string containing captured ASCII character representing a key, or a control character like <code>\"\\r\"</code> (enter), <code>\"\\u0001\"</code> (ctrl-a), <code>\"\\u0003\"</code> (ctrl-c), etc. Like with <code>\"o\"</code> event, it's UTF-8 encoded JSON string, with any non-printable Unicode codepoints encoded as <code>\\uXXXX</code>.</p> <p>Example:</p> <pre><code>[5.0, \"i\", \"h\"]\n</code></pre> <p>Note</p> <p>asciinema CLI doesn't capture keyboard input by default. All implementations of asciicast-compatible terminal recorder should not capture it either unless explicitly requested by the user.</p>"},{"location":"manual/asciicast/v2/#m-marker","title":"m - marker","text":"<p>Event with code <code>\"m\"</code> represents a marker.</p> <p>Markers can act as breakpoints or be used for playback navigation and automation.</p> <p><code>data</code>, which specifies a label, is optional (can be empty string). Labels may be used to e.g. create a list of named \"chapters\".</p> <p>Example:</p> <pre><code>[5.0,  \"m\", \"\"] // unlabeled marker\n[10.0, \"m\", \"Configuration\"] // labeled marker\n</code></pre>"},{"location":"manual/asciicast/v2/#r-resize","title":"r - resize","text":"<p>Event with code <code>\"r\"</code> represents terminal resize.</p> <p>Those are captured in response to <code>SIGWINCH</code> signal.</p> <p><code>data</code> contains new terminal size (columns + rows) formatted as <code>\"{COLS}x{ROWS}\"</code>.</p> <pre><code>[5.0, \"r\", \"100x50\"]\n</code></pre>"},{"location":"manual/asciicast/v2/#file-extension","title":"File extension","text":"<p>Suggested file extension is <code>.cast</code>.</p>"},{"location":"manual/asciicast/v2/#media-type-mime","title":"Media type (MIME)","text":"<p>Suggested media type is <code>application/x-asciicast</code>.</p>"},{"location":"manual/asciicast/v2/#note-on-compatibility","title":"Note on compatibility","text":"<p>asciicast v2 file format enables incremental, real-time writing to disk, which was not possible with v1 format. The main benefits are:</p> <ul> <li>minimal memory usage when recording and replaying arbitrarily long sessions -   disk space is the only limit,</li> <li>when the recording session is interrupted (e.g. computer crash, accidental   close of terminal window) you don't lose the whole recording,</li> <li>it's real-time streaming friendly.</li> </ul> <p>However, due to file structure change (standard JSON =&gt; newline-delimited JSON) version 2 is not backward compatible with version 1.</p> <p>Support for asciicast v2 has been added in:</p> <ul> <li>asciinema cli v2.0</li> <li>asciinema player v2.6</li> <li>asciinema server v20171105</li> </ul>"},{"location":"manual/asciicast/v3/","title":"asciicast v3","text":"<p>asciicast v3 is a file format for terminal sessions recorded by asciinema CLI 3.0 and later.</p> <p>It's based on newline-delimited JSON.</p> <p>First line, encoded as JSON object, represents the header, which contains metadata, such as initial terminal size, timestamp, etc.</p> <p>All following lines form the event stream. Each line represents a separate event, encoded as 3-element JSON array.</p> <p>Lines starting with <code>#</code> character are treated as comments and ignored for most intents and purposes. The first line of the file must not be a comment.</p> <p>asciicast v3 file looks like this:</p> <pre><code>{\"version\": 3, \"term\": {\"cols\": 80, \"rows\": 24, \"type\": \"xterm-256color\"}, \"timestamp\": 1504467315, \"title\": \"Demo\", \"env\": {\"SHELL\": \"/bin/zsh\"}}\n# event stream follows the header\n[0.248, \"o\", \"\\u001b[1;31mHello \\u001b[32mWorld!\\u001b[0m\\n\"]\n[1.001, \"o\", \"That was ok\\rThis is better.\"]\n[3.500, \"m\", \"\"]\n[0.143, \"o\", \"Now... \"]\n# terminal window resized to 90 cols and 30 rows\n[2.050, \"r\", \"90x30\"]\n[1.541, \"o\", \"Bye!\"]\n[0.887, \"x\", \"0\"]\n</code></pre>"},{"location":"manual/asciicast/v3/#header","title":"Header","text":"<p>asciicast header is JSON-encoded object containing recording metadata.</p> <p>Complete header example, pretty formatted for readability:</p> <pre><code>{\n  \"version\": 3,\n  \"term\": {\n    \"cols\": 80,\n    \"rows\": 24,\n    \"type\": \"xterm-256color\",\n    \"version\": \"VTE(7802)\",\n    \"theme\": {\n      \"fg\": \"#d0d0d0\",\n      \"bg\": \"#212121\",\n      \"palette\": \"#151515:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#d0d0d0:#505050:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#f5f5f5\"\n    }\n  },\n  \"timestamp\": 1509091818,\n  \"idle_time_limit\": 2,\n  \"command\": \"/bin/bash\",\n  \"title\": \"Demo\",\n  \"env\": {\n    \"SHELL\": \"/bin/bash\"\n  },\n  \"tags\": [\"demo\", \"tutorial\", \"helix\"]\n}\n</code></pre> <p>Minimal header example:</p> <pre><code>{\"version\": 3, \"term\": {\"cols\": 80, \"rows\": 24}}\n</code></pre> <p>Below list contains all attributes supported in the header. Attributes not marked as required may be omitted from the header, as seen in the minimal example above.</p> <p>New attributes may be added to the header in later revisions of this spec, therefore tools MUST ignore (or pass through) header attributes they don't understand.</p>"},{"location":"manual/asciicast/v3/#version","title":"<code>version</code>","text":"<p>Format version number.</p> <p>Must be set to <code>3</code>.</p> <p>Required field.</p> <p>Type: integer</p>"},{"location":"manual/asciicast/v3/#term","title":"<code>term</code>","text":"<p>Terminal information.</p> <p>Required field.</p> <p>Type: object with the following attributes:</p>"},{"location":"manual/asciicast/v3/#cols","title":"<code>cols</code>","text":"<p>Terminal width, i.e. number of columns.</p> <p>Required field.</p> <p>Type: integer</p>"},{"location":"manual/asciicast/v3/#rows","title":"<code>rows</code>","text":"<p>Terminal height, i.e. number of rows.</p> <p>Required field.</p> <p>Type: integer</p>"},{"location":"manual/asciicast/v3/#type","title":"<code>type</code>","text":"<p>Terminal type, e.g. xterm-256color.</p> <p>Type: string</p>"},{"location":"manual/asciicast/v3/#version_1","title":"<code>version</code>","text":"<p>Terminal version as reported by XTVERSION OSC query.</p> <p>Type: string</p>"},{"location":"manual/asciicast/v3/#theme","title":"<code>theme</code>","text":"<p>Color theme of the recorded terminal.</p> <p>Type: object, with the following attributes (all required):</p> <ul> <li><code>fg</code> - normal text color,</li> <li><code>bg</code> - normal background color,</li> <li><code>palette</code> - list of 8 or 16 colors, separated by colon character.</li> </ul> <p>All colors are in the CSS <code>#rrggbb</code> format.</p> <p>Example theme, pretty formatted for readability:</p> <pre><code>{\n  \"fg\": \"#d0d0d0\",\n  \"bg\": \"#212121\",\n  \"palette\": \"#151515:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#d0d0d0:#505050:#ac4142:#7e8e50:#e5b567:#6c99bb:#9f4e85:#7dd6cf:#f5f5f5\"\n}\n</code></pre> <p>Note</p> <p>asciinema CLI captures the original terminal theme automatically (since v3.0).</p> <p>If you're implementing an asciicast-compatible recorder, then you can retrieve the colors from the terminal via OSC sequences (this is how asciinema recorder does it). However, you can also use another technique, or even hard-code the colors of your favorite theme.</p>"},{"location":"manual/asciicast/v3/#timestamp","title":"<code>timestamp</code>","text":"<p>Unix timestamp of the beginning of the recording session.</p> <p>Type: integer</p>"},{"location":"manual/asciicast/v3/#idle_time_limit","title":"<code>idle_time_limit</code>","text":"<p>Idle time limit, as given via <code>-i</code> option to <code>asciinema rec</code>.</p> <p>Type: float</p> <p>This should be used by an asciicast player to reduce all terminal inactivity (delays between frames) to a maximum of <code>idle_time_limit</code> value.</p>"},{"location":"manual/asciicast/v3/#command","title":"<code>command</code>","text":"<p>Command that was recorded, as given via <code>-c</code> option to <code>asciinema rec</code>.</p> <p>Type: string</p>"},{"location":"manual/asciicast/v3/#title","title":"<code>title</code>","text":"<p>Title of the recording, as given via <code>-t</code> option to <code>asciinema rec</code>.</p> <p>Type: string</p>"},{"location":"manual/asciicast/v3/#env","title":"<code>env</code>","text":"<p>A map of captured environment variables.</p> <p>Type: object (String -&gt; String).</p> <p>Example env:</p> <pre><code>{\"SHELL\": \"/bin/bash\", \"TERM\": \"xterm-256color\"}\n</code></pre> <p>Official asciinema recorder captures only <code>SHELL</code> variable by default. All implementations of asciicast-compatible terminal recorder should not capture any additional environment variables unless explicitly requested by the user.</p>"},{"location":"manual/asciicast/v3/#tags","title":"<code>tags</code>","text":"<p>A list of tags for adding context to recordings.</p> <p>Type: array of strings</p> <p>Tags can be used by official and community-developed tooling for e.g., search/filtering. Common use cases include categorizing recordings by topic (e.g., \"tutorial\", \"demo\"), technology (e.g., \"elixir\", \"podman\"), or purpose (e.g., \"testing\", \"documentation\").</p> <p>Example tags:</p> <pre><code>[\"demo\", \"tutorial\", \"neovim\", \"jj\"]\n</code></pre>"},{"location":"manual/asciicast/v3/#event-stream","title":"Event stream","text":"<p>Each element of the event stream is a 3-tuple encoded as JSON array:</p> <pre><code>[interval, code, data]\n</code></pre> <p>Where:</p> <ul> <li><code>interval</code> (float) - time interval from the previous event (in seconds),</li> <li><code>code</code> (string) - event type code, one of: <code>\"o\"</code>, <code>\"i\"</code>, <code>\"m\"</code>, <code>\"r\"</code>, <code>\"x\"</code></li> <li><code>data</code> (string) - event specific data, described separately for each event   code.</li> </ul> <p>For example, let's look at the following line:</p> <pre><code>[1.001, \"o\", \"Hello world\"]\n</code></pre> <p>It represents:</p> <ul> <li>output (code <code>o</code>),</li> <li>of text <code>Hello world</code>,</li> <li>which happened <code>1.001</code> sec after the previous event.</li> </ul>"},{"location":"manual/asciicast/v3/#supported-event-codes","title":"Supported event codes","text":"<p>This section describes the event codes supported in asciicast v3 format.</p> <p>The list is open to extension, and new event codes may be added in both the current and future versions of the format. For example, we may add new event code for text overlay (subtitles display).</p> <p>A tool which interprets the event stream (a player or a post-processor) MUST ignore (or pass through) events with codes it doesn't understand or doesn't care about.</p>"},{"location":"manual/asciicast/v3/#o-output-data-written-to-a-terminal","title":"o - output, data written to a terminal","text":"<p>Event with code <code>\"o\"</code> represents printing new data to a terminal.</p> <p><code>data</code> is a string containing the data that was printed. It must be valid, UTF-8 encoded JSON string as described in JSON RFC section 2.5, with any non-printable Unicode codepoints encoded as <code>\\uXXXX</code>.</p> <p>Example:</p> <pre><code>[5.0, \"o\", \"hello\"]\n</code></pre>"},{"location":"manual/asciicast/v3/#i-input-data-read-from-a-terminal","title":"i - input, data read from a terminal","text":"<p>Event with code <code>\"i\"</code> represents character typed in by the user, or more specifically, raw data sent from a terminal emulator to stdin of the recorded program (usually shell).</p> <p><code>data</code> is a string containing captured ASCII character representing a key, or a control character like <code>\"\\r\"</code> (enter), <code>\"\\u0001\"</code> (ctrl-a), <code>\"\\u0003\"</code> (ctrl-c), etc. Like with <code>\"o\"</code> event, it's UTF-8 encoded JSON string, with any non-printable Unicode codepoints encoded as <code>\\uXXXX</code>.</p> <p>Example:</p> <pre><code>[5.0, \"i\", \"h\"]\n</code></pre> <p>Note</p> <p>asciinema CLI doesn't capture keyboard input by default. All implementations of asciicast-compatible terminal recorder should not capture it either unless explicitly requested by the user.</p>"},{"location":"manual/asciicast/v3/#m-marker","title":"m - marker","text":"<p>Event with code <code>\"m\"</code> represents a marker.</p> <p>Markers can act as breakpoints or be used for playback navigation and automation.</p> <p><code>data</code>, which specifies a label, is optional (can be empty string). Labels may be used to e.g. create a list of named \"chapters\".</p> <p>Example:</p> <pre><code>[5.0,  \"m\", \"\"] // unlabeled marker\n[3.0, \"m\", \"Configuration\"] // labeled marker\n</code></pre>"},{"location":"manual/asciicast/v3/#r-resize","title":"r - resize","text":"<p>Event with code <code>\"r\"</code> represents terminal resize.</p> <p>Those are captured in response to <code>SIGWINCH</code> signal.</p> <p><code>data</code> contains new terminal size (columns + rows) formatted as <code>\"{COLS}x{ROWS}\"</code>.</p> <p>Example:</p> <pre><code>[5.0, \"r\", \"100x50\"]\n</code></pre>"},{"location":"manual/asciicast/v3/#x-exit","title":"x - exit","text":"<p>Event with code <code>\"x\"</code> represents session exit status.</p> <p><code>data</code> is a numerical exit status of session's main child process (e.g. a shell).</p> <p>This event is typically included only once, as the very last event of the recording.</p> <p>Example:</p> <pre><code>[5.0, \"x\", \"0\"]\n</code></pre>"},{"location":"manual/asciicast/v3/#file-extension","title":"File extension","text":"<p>Suggested file extension is <code>.cast</code>.</p>"},{"location":"manual/asciicast/v3/#media-type-mime","title":"Media type (MIME)","text":"<p>Suggested media type is <code>application/x-asciicast</code>.</p>"},{"location":"manual/asciicast/v3/#note-on-compatibility","title":"Note on compatibility","text":"<p>asciicast v3 file format is not backward compatible with asciicast v1/v2 due to the header schema changes and use of relative time (intervals) in the event stream (even though v1 uses relative time too).</p> <p>However, the changes between v2 and v3 are relatively small when compared with the changes between v1 and v2. Both v2 and v3 use the same newline-delimited JSON format, with the first line being the header, and the following lines being the event stream. Also, aside from time/intervals, both v2 and v3 use the same notation and event codes for the event stream.</p> <p>Support for asciicast v3 has been added in:</p> <ul> <li>asciinema cli v3.0</li> <li>asciinema player v3.10.0</li> <li>asciinema server 20250509</li> </ul>"},{"location":"manual/asciicast/v3/#revisions-of-this-spec","title":"Revisions of this spec","text":"<p>2025-09-10 - Initial version 2025-10-20 - Changed time precision in event examples from microseconds to milliseconds</p>"},{"location":"manual/cli/","title":"asciinema CLI","text":"<p>asciinema CLI (also known as asciinema \"client\" or \"recorder\") is a command-line tool for recording and live streaming terminal sessions.</p> <p>Unlike typical screen recording software, which records visual output of a screen into a heavyweight video files (<code>.mp4</code>, <code>.mov</code>), asciinema CLI runs inside a terminal, capturing terminal session output into lightweight recording files in the asciicast format (<code>.cast</code>), or streaming it live to viewers in real-time.</p> <p>Recordings can be replayed in a terminal, embedded on a web page with the asciinema player, or published to an asciinema server, such as asciinema.org, for further sharing. Live streams allow viewers to watch terminal sessions as they happen.</p> <p>Recording a terminal with asciicast is just:</p> <pre><code>asciinema rec demo.cast\n</code></pre> <p>Similarly, live terminal streaming is as simple as:</p> <pre><code>asciinema stream -r\n</code></pre> <p>Check out the quick start guide for installation and usage overview.</p> <p>Notable features:</p> <ul> <li>recording and replaying of sessions inside a terminal,</li> <li>local and remote live streaming   of terminal sessions to multiple viewers in real-time,</li> <li>lightweight recording format, which is highly   compressible (down to 15% of the original size e.g. with <code>zstd</code> or <code>gzip</code>),</li> <li>integration with asciinema server, e.g.   asciinema.org, for easy recording hosting and live   streaming.</li> </ul> <p>asciinema CLI is free and open-source software (FOSS). Source code and license available at github.com/asciinema/asciinema.</p>"},{"location":"manual/cli/desktop-notifications/","title":"Desktop notifications","text":"<p>During a recording session there are several situations where asciinema CLI needs to display a user notification. Typical scenarios include:</p> <ul> <li>recording is suspended/resumed with ctrl+\\ shortcut,</li> <li>marker is added, with a user-defined shortcut,</li> <li>file write error happens,</li> <li>live stream gets disconnected from the server.</li> </ul> <p>The notification must happen without printing anything to a terminal, therefore asciinema uses native desktop notifications for this, which don't interfere with the state of the terminal. This works out of the box on Linux (via <code>notify-send</code>) and macOS (<code>osascript</code>).</p> <p>Note</p> <p>Technically the recorder could show a notification inside a terminal by just printing a message but this can potentially mess up the output/expectations of a program currently running in the foreground, e.g. a shell, vim etc.</p> <p>You can disable desktop notifications with the <code>notifications.enabled</code> option in the config file:</p> CLI 3.xCLI 2.x ~/.config/asciinema/config.toml<pre><code>[notifications]\nenabled = false\n</code></pre> ~/.config/asciinema/config<pre><code>[notifications]\nenabled = no\n</code></pre>"},{"location":"manual/cli/desktop-notifications/#custom-notification-command","title":"Custom notification command","text":"<p>A custom notification command can be configured with the <code>notifications.command</code>.</p> <p>The command is executed with the following environment variables:</p> <ul> <li><code>TEXT</code> - set to the notification text,</li> <li><code>ICON_PATH</code> - set to the path of the asciinema logo icon.</li> </ul> <p>Below is an example of tmux status bar integration:</p> CLI 3.xCLI 2.x ~/.config/asciinema/config.toml<pre><code>[notifications]\ncommand = 'tmux display-message \"$TEXT\"'\n</code></pre> ~/.config/asciinema/config<pre><code>[notifications]\ncommand = tmux display-message \"$TEXT\"\n</code></pre> <p>The command is executed in a shell (<code>/bin/sh</code>), therefore it's possible to use shell constructs like pipes.</p>"},{"location":"manual/cli/installation/","title":"Installation","text":"<p>asciinema CLI can be installed in the following ways:</p> <ul> <li>using a package manager on Linux, macOS, and FreeBSD - search for a package   named <code>asciinema</code>,</li> <li>downloading a pre-built, static binary of the latest version from the   releases page,</li> <li>using a container image,</li> <li>building from source.</li> </ul> <p>Older versions of asciinema (2.x) can also be obtained as the PyPI package.</p>"},{"location":"manual/cli/installation/#linux","title":"Linux","text":""},{"location":"manual/cli/installation/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S asciinema\n</code></pre>"},{"location":"manual/cli/installation/#debian","title":"Debian","text":"<pre><code>sudo apt install asciinema\n</code></pre>"},{"location":"manual/cli/installation/#fedora","title":"Fedora","text":"<pre><code>sudo dnf install asciinema\n</code></pre>"},{"location":"manual/cli/installation/#gentoo","title":"Gentoo","text":"<pre><code>sudo emerge -av asciinema\n</code></pre>"},{"location":"manual/cli/installation/#nixos-nix","title":"NixOS / Nix","text":"nix-envnix-shellNixOS configurationhome-manager <pre><code>nix-env -i asciinema\n</code></pre> <pre><code>nix-shell -p asciinema\n</code></pre> /etc/nixos/configuration.nix<pre><code>environment.systemPackages = [\n  pkgs.asciinema\n]\n</code></pre> ~/.config/home-manager/home.nix<pre><code>home.packages = [\n  pkgs.asciinema\n]\n</code></pre>"},{"location":"manual/cli/installation/#opensuse","title":"openSUSE","text":"<pre><code>sudo zypper install asciinema\n</code></pre>"},{"location":"manual/cli/installation/#ubuntu","title":"Ubuntu","text":"22.04 or newerPPA <pre><code>sudo apt install asciinema\n</code></pre> <p>David Adam (zanchey) maintains asciinema PPA.</p> <pre><code>sudo apt-add-repository ppa:zanchey/asciinema\nsudo apt update\nsudo apt install asciinema\n</code></pre>"},{"location":"manual/cli/installation/#macos","title":"macOS","text":"HomebrewMacPortsNix <pre><code>brew install asciinema\n</code></pre> <pre><code>sudo port selfupdate &amp;&amp; sudo port install asciinema\n</code></pre> <pre><code>nix-env -i asciinema\n</code></pre>"},{"location":"manual/cli/installation/#freebsd","title":"FreeBSD","text":"PortsPackages <pre><code>cd /usr/ports/textproc/py-asciinema &amp;&amp; make install\n</code></pre> <pre><code>pkg install py39-asciinema\n</code></pre>"},{"location":"manual/cli/installation/#openbsd","title":"OpenBSD","text":"<pre><code>pkg_add asciinema\n</code></pre>"},{"location":"manual/cli/installation/#pypi","title":"PyPI","text":"<p>asciinema CLI 2.x is available on PyPI and can be installed with <code>pipx</code>.</p> pipxpip <p>If you have pipx installed:</p> <pre><code>pipx install asciinema\n</code></pre> <p>Alternatively use <code>pip</code> (Python 3 with <code>setuptools</code> required):</p> <pre><code>python3 -m pip install asciinema\n</code></pre>"},{"location":"manual/cli/installation/#container-image","title":"Container image","text":"<p>asciinema OCI container image is based on Ubuntu 22.04 and has the latest version of asciinema recorder pre-installed.</p> <p>Pull the container:</p> podmandocker <pre><code>podman pull ghcr.io/asciinema/asciinema\n</code></pre> <pre><code>docker pull ghcr.io/asciinema/asciinema\n</code></pre> <p>Container's entrypoint is set to <code>asciinema</code> binary therefore you can run the container with arguments you would normally pass to <code>asciinema</code> command (run <code>asciinema --help</code> for commands and options).</p> <p>When running the container it's essential to allocate a pseudo-TTY (<code>-t</code>) and keep STDIN open (<code>-i</code>).</p> podmandocker <pre><code>podman run --rm -it ghcr.io/asciinema/asciinema\n</code></pre> <pre><code>docker run --rm -it ghcr.io/asciinema/asciinema\n</code></pre> <p>You can optionally bind-mount config directory (<code>-v</code>):</p> podmandocker <pre><code>podman run --rm -it -v \"$HOME/.config/asciinema:/root/.config/asciinema\" ghcr.io/asciinema/asciinema\n</code></pre> <pre><code>docker run --rm -it -v \"$HOME/.config/asciinema:/root/.config/asciinema\" ghcr.io/asciinema/asciinema\n</code></pre> <p>Note</p> <p>If you plan to upload your recordings to asciinema.org then it's recommended to preserve asciinema config directory between runs, e.g. by bind-mounting it as shown above. This directory stores install ID, which links all recordings uploaded from a given system to your asciinema.org user account.</p> <p>To be able to save the recordings locally bind-mount your working directory like this:</p> podmandocker <pre><code>podman run --rm -it -v \"$PWD:/root\" --workdir=/data ghcr.io/asciinema/asciinema rec demo.cast\n</code></pre> <pre><code>docker run --rm -it -v \"$PWD:/root\" --workdir=/data ghcr.io/asciinema/asciinema rec demo.cast\n</code></pre> <p>There's not much software installed in this image. In most cases you may want to install extra programs before recording. One option is to derive a new image from this one (start your custom Dockerfile with <code>FROM ghcr.io/asciinema/asciinema</code>). Another option is to start the container with <code>/bin/bash</code> as the entrypoint, install extra packages and then start recording with <code>asciinema rec</code>:</p> podmandocker <pre><code>podman run --rm -it --entrypoint=/bin/bash ghcr.io/asciinema/asciinema\nroot@6689517d99a1:~# apt install foobar\nroot@6689517d99a1:~# asciinema rec demo.cast\n</code></pre> <pre><code>docker run --rm -it --entrypoint=/bin/bash ghcr.io/asciinema/asciinema\nroot@6689517d99a1:~# apt install foobar\nroot@6689517d99a1:~# asciinema rec demo.cast\n</code></pre> <p>With Docker, it's also possible to run the container as a non-root user, which has security benefits. You can specify user and group id at runtime to give the application permission similar to the calling user on your host.</p> <pre><code>docker run --rm -it \\\n    --env=ASCIINEMA_CONFIG_HOME=\"/run/user/$(id -u)/.config/asciinema\" \\\n    --user=\"$(id -u):$(id -g)\" \\\n    --volume=\"${HOME}/.config/asciinema:/run/user/$(id -u)/.config/asciinema:rw\" \\\n    --volume=\"${PWD}:/data:rw\" \\\n    --workdir=/data \\\n    ghcr.io/asciinema/asciinema rec\n</code></pre> <p>Note</p> <p>Podman has first class support for rootless operation.</p>"},{"location":"manual/cli/installation/#from-source","title":"From source","text":"<p>You can build latest development version of asciinema CLI by using Rust's cargo package manager:</p> <pre><code>cargo install --locked --git https://github.com/asciinema/asciinema\n</code></pre> <p>If you'd like to modify the code, then clone the git repository and run asciinema CLI straight from the checkout:</p> <pre><code>git clone https://github.com/asciinema/asciinema.git\ncd asciinema\ncargo run --release -- --help\n</code></pre>"},{"location":"manual/cli/markers/","title":"Markers","text":"<p>Markers are specific time locations in a recording, useful for automation of the playback. <code>asciinema play -m</code> command can use them as breakpoints, while asciinema web player can also use them for navigation and advanced automation.</p>"},{"location":"manual/cli/markers/#adding-markers-to-a-recording","title":"Adding markers to a recording","text":"<p>Markers can be added to a recording in two ways.</p> <p>During a recording session, you can add markers in real-time by pressing a configured keyboard shortcut. Set <code>rec.add_marker_key</code> config file option first as there's no default binding at the moment. When a marker is added a desktop notification is displayed.</p> <p>For existing recordings, you can edit the asciicast file with your favourite editor and insert marker events at desired time locations. See marker events in asciicasts for more information.</p>"},{"location":"manual/cli/markers/#markers-as-breakpoints","title":"Markers as breakpoints","text":"<p>When replaying a recording in a terminal you can use <code>-m</code>/<code>--pause-on-markers</code> flag to enable auto-pause-on-marker behaviour:</p> <pre><code>asciinema play -m demo.cast\n</code></pre> <p>In this mode, when a marker is encountered, the playback automatically pauses and can be resumed by pressing space key (or a shortcut of your choice). The playback continues until the next marker is encountered. When paused, you can also jump to the next marker by pressing ] key (also configurable).</p> <p>Tip</p> <p>Breakpoints can be useful in live demos: you can prepare a recording with markers, and have it stop automatically wherever you want to explain terminal contents in more detail.</p>"},{"location":"manual/cli/quick-start/","title":"Quick start","text":"<p>This guide shows how to use asciinema CLI for recording, replaying, publishing, and live streaming terminal sessions.</p> <p>For a broader overview of what's possible with asciinema check out the intro guide.</p>"},{"location":"manual/cli/quick-start/#install-asciinema-cli","title":"Install asciinema CLI","text":"<p>asciinema CLI is available in most package repositories on Linux, macOS, and FreeBSD. Search for a package named <code>asciinema</code>.</p> apt (Debian, Ubuntu)pacman (Arch, Manjaro)homebrew (macOS)CargoOther <pre><code>sudo apt install asciinema\n</code></pre> <pre><code>sudo pacman -S asciinema\n</code></pre> <pre><code>brew install asciinema\n</code></pre> <p>You can install latest development version with <code>cargo</code>:</p> <pre><code>cargo install --locked --git https://github.com/asciinema/asciinema\n</code></pre> <p>Check the Installation section for all installation options.</p> <p>You can also download a pre-built, static binary of the latest version from the releases page.</p>"},{"location":"manual/cli/quick-start/#record-a-terminal-session","title":"Record a terminal session","text":"<p>To start a recording session use the <code>rec</code> command:</p> <pre><code>asciinema rec demo.cast\n</code></pre> <p>When done, press ctrl+d or enter <code>exit</code> to end the recording.</p> <p>Instead of recording a shell you can record any command with <code>--command</code> / <code>-c</code> option:</p> <pre><code>asciinema rec -c htop demo.cast\n</code></pre> <p>The recording ends when you exit <code>htop</code> by pressing its <code>q</code> shortcut.</p> <p>Run <code>asciinema rec --help</code> for all recording options.</p>"},{"location":"manual/cli/quick-start/#replay-directly-in-a-terminal","title":"Replay directly in a terminal","text":"<p>To replay a recording in your terminal use the <code>play</code> command:</p> <pre><code>asciinema play demo.cast\n</code></pre> <p>To replay it with double speed use <code>--speed</code> / <code>-s</code> option:</p> <pre><code>asciinema play -s 2 demo.cast\n</code></pre> <p>A unique feature of asciinema is the ability to optimize away idle moments in a recording using the <code>--idle-time-limit</code> / <code>-i</code> option:</p> <pre><code>asciinema play -i 2 demo.cast\n</code></pre> <p>You can pass <code>-i 2</code> to <code>asciinema rec</code> as well, to set it permanently on a recording. Idle time limiting makes the recordings much more interesting to watch. Try it!</p> <p>Run <code>asciinema play --help</code> for all playback options.</p> <p>Tip</p> <p>For the best playback experience it is recommended to run <code>asciinema play</code> in a terminal of size equal or bigger than the one used at the recording time, as there's no \"transcoding\" of control sequences for the current terminal size.</p>"},{"location":"manual/cli/quick-start/#share-via-asciinemaorg","title":"Share via asciinema.org","text":"<p>If you want to watch and share it on the web, upload it:</p> <pre><code>asciinema upload demo.cast\n</code></pre> <p>The above command uploads it to asciinema.org, which is a default asciinema server instance, and prints a secret link you can use to watch your recording in a web browser.</p> <p>Run <code>asciinema upload --help</code> for all upload options.</p> <p>Note</p> <p>This step is completely optional. You can embed your recordings on a web page with asciinema player, or publish them to a self-hosted asciinema server instance.</p>"},{"location":"manual/cli/quick-start/#stream-a-terminal-session","title":"Stream a terminal session","text":"<p>To stream your terminal live to asciinema.org:</p> <pre><code>asciinema stream -r\n</code></pre> <p>Similarly to the <code>upload</code> command, this one also lets you stream to a self-hosted asciinema server instance.</p> <p>To stream locally:</p> <pre><code>asciinema stream -l\n</code></pre> <p>This starts a local web server which lets you watch the stream from a local machine or over LAN.</p> <p>Run <code>asciinema stream --help</code> for more streaming options.</p> <p>Note</p> <p>Live streaming requires asciinema CLI 3.0 or newer.</p> <p>Finally, you can stream and record to a file at the same time:</p> <pre><code>asciinema session -o demo.cast -r -l\n</code></pre> <p>The session command is a more generic variant of <code>rec</code> and <code>stream</code>, that can do everything those two commands can.</p> <p>Run <code>asciinema session --help</code> for more details.</p>"},{"location":"manual/cli/quick-start/#next","title":"Next","text":"<p>These are the basics, but there's much more. We highly encourage checking out <code>--help</code> information for each command - it contains way more information than was covered in this guide.</p> <p>Last but not least! Consider creating shell aliases for frequently used commands:</p> <pre><code>alias rec='asciinema rec'\nalias play='asciinema play'\nalias stream='asciinema stream -r'\n</code></pre> <p>Happy recording!</p>"},{"location":"manual/cli/shortcuts/","title":"Keyboard shortcuts","text":"<p>There are several key bindings used by the CLI during recording and playback. Most of them can be customized in the config file.</p>"},{"location":"manual/cli/shortcuts/#recording-shortcuts","title":"Recording shortcuts","text":"<p>The following keyboard shortcuts are available when recording with <code>asciinema rec</code>:</p> shortcut action 3.x config file option 2.x config file option notes ctrl+\\ toggle the capture of a terminal <code>recording.pause_key</code> <code>rec.pause_key</code> similar to \"mute\" on an audio call ctrl+d end the recording session - - this is handled by a shell - add a marker <code>recording.add_marker_key</code> <code>rec.add_marker_key</code> no default shortcut for this"},{"location":"manual/cli/shortcuts/#playback-shortcuts","title":"Playback shortcuts","text":"<p>The following keyboard shortcuts are available when replaying with <code>asciinema play</code>:</p> shortcut action 3.x config file option 2.x config file option notes space toggle the playback <code>playback.pause_key</code> <code>play.pause_key</code> pauses / resumes ] jump to next marker <code>playback.next_marker_key</code> <code>play.next_marker_key</code> . step (when paused) <code>playback.step_key</code> <code>play.step_key</code> steps through a recordinga frame at a time ctrl+c stop - - ends the playback"},{"location":"manual/cli/shortcuts/#prefix-key","title":"Prefix key","text":"<p>You can define a \"prefix key\" for the recording shortcuts with <code>rec.prefix_key</code> option in the config file:</p> CLI 3.0+CLI 2.0+ ~/.config/asciinema/config.toml<pre><code>[recording]\nprefix_key = \"C-a\"\n</code></pre> ~/.config/asciinema/config<pre><code>[rec]\nprefix_key = C-a\n</code></pre> <p>This works similarly to a prefix key in GNU screen or tmux. By default there's no prefix key enabled.</p> <p>Note</p> <ol> <li> <p>Prefix key doesn't affect the ctrl+d shortcut used for ending the recording session. That is because ctrl+d is a shortcut handled by a shell (making it exit), not by asciinema recorder.</p> </li> <li> <p>There's no prefix key concept for the <code>play</code> command because there's no interactive process to forward the key presses during the playback, and therefore no risk of shortcut conflicts.</p> </li> </ol>"},{"location":"manual/cli/configuration/","title":"Configuration","text":"<p>You can configure asciinema CLI with a config file.</p> <p>The most common use-case is setting the URL of a self-hosted asciinema server:</p> CLI 3.0+CLI 2.0+ ~/.config/asciinema/config.toml<pre><code>[server]\nurl = \"https://asciinema.example.com\"\n</code></pre> ~/.config/asciinema/config<pre><code>[api]\nurl = https://asciinema.example.com\n</code></pre> <p>Alternatively you can set it with environment variable in your shell config file:</p> CLI 3.0+CLI 2.0+ ~/.bashrc<pre><code>export ASCIINEMA_SERVER_URL=https://asciinema.example.com\n</code></pre> ~/.bashrc<pre><code>export ASCIINEMA_API_URL=https://asciinema.example.com\n</code></pre> <p>There's more things you can configure. For the full list of options check out the documentation for asciinema CLI version you use:</p> <ul> <li>CLI 3.0+ configuration</li> <li>CLI 2.0+ configuration</li> </ul> <p>Tip</p> <p>During recording sessions, asciinema sets the <code>ASCIINEMA_SESSION</code> environment variable to a unique session ID. This can be used to detect active recording sessions in your shell config file (<code>.bashrc</code>, <code>.zshrc</code>) in order to e.g. alter the prompt, play a sound, or change the background color of a terminal emulator window.</p> <p>For example:</p> .bashrc<pre><code>if [ -n \"$ASCIINEMA_SESSION\" ]; then\n  play \"ding.wav\"\nfi\n</code></pre>"},{"location":"manual/cli/configuration/v2/","title":"CLI 2.0+ configuration","text":""},{"location":"manual/cli/configuration/v2/#config-file","title":"Config file","text":"<p>You can configure asciinema CLI 2.0+ by creating a config file at <code>$HOME/.config/asciinema/config</code>.</p> <p>Here's an overview of all available options for each configuration section.</p> ~/.config/asciinema/config<pre><code>[api]\n\n; API server URL, default: https://asciinema.org\n; If you run your own instance of asciinema server then set its address here\n; It can also be overridden by setting ASCIINEMA_API_URL environment variable\nurl = https://asciinema.example.com\n\n[record]\n\n; Command to record, default: $SHELL\ncommand = /bin/bash -l\n\n; Enable stdin (keyboard) recording, default: no\nstdin = yes\n\n; List of environment variables to capture, default: SHELL,TERM\nenv = SHELL,TERM,USER\n\n; Limit recorded terminal inactivity to max n seconds, default: off\nidle_time_limit = 2\n\n; Answer \"yes\" to all interactive prompts, default: no\nyes = true\n\n; Be quiet, suppress all notices/warnings, default: no\nquiet = true\n\n; Define hotkey for pausing recording (suspending capture of output),\n; default: C-\\ (control + backslash)\npause_key = C-p\n\n; Define hotkey for adding a marker, default: none\nadd_marker_key = C-x\n\n; Define hotkey prefix key - when defined other recording hotkeys must\n; be preceded by it, default: no prefix\nprefix_key = C-a\n\n[play]\n\n; Playback speed (can be fractional), default: 1\nspeed = 2\n\n; Limit replayed terminal inactivity to max n seconds, default: off\nidle_time_limit = 1\n\n; Define hotkey for pausing/resuming playback,\n; default: space\npause_key = p\n\n; Define hotkey for stepping through playback, a frame at a time,\n; default: . (dot)\nstep_key = s\n\n; Define hotkey for jumping to the next marker,\n; default: ]\nnext_marker_key = m\n\n[notifications]\n; Desktop notifications are displayed in several situations, e.g. when\n; pausing/resuming the capture of terminal with C-\\ keyboard shortcut.\n\n; Should desktop notifications be enabled, default: yes\nenabled = no\n\n; Custom notification command\n; asciinema automatically detects available desktop notification system\n; (notify-send on GNU/Linux, osacript on macOS). Custom command can be\n; used if needed.\n; When invoked, environment variable $TEXT contains notification text, while\n; $ICON_PATH contains path to the asciinema logo image.\ncommand = tmux display-message \"$TEXT\"\n</code></pre> <p>A minimal config file could look like this:</p> <pre><code>[record]\nidle_time_limit = 2\n</code></pre>"},{"location":"manual/cli/configuration/v2/#environment-variables","title":"Environment variables","text":""},{"location":"manual/cli/configuration/v2/#asciinema_api_url","title":"<code>ASCIINEMA_API_URL</code>","text":"<p>Specifies base URL of an asciinema server, used for recording uploads.</p> <p>Defaults to <code>https://asciinema.org</code>. Can also be set in the config file as <code>api.url</code>.</p> <p>If you self-host asciinema server then you should set <code>ASCIINEMA_API_URL</code> to its base URL, e.g. <code>https://asciinema.example.com</code>.</p>"},{"location":"manual/cli/configuration/v2/#asciinema_config_home","title":"<code>ASCIINEMA_CONFIG_HOME</code>","text":"<p>Specifies config directory path.</p> <p>Defaults to <code>$XDG_CONFIG_HOME/asciinema</code> if <code>XDG_CONFIG_HOME</code> is set, otherwise defaults to <code>$HOME/.config/asciinema</code>.</p> <p>Note</p> <p>asciinema versions prior to 1.1 used <code>$HOME/.asciinema</code> for the config directory. If you have it there, it's recommended to <code>mv $HOME/.asciinema $HOME/.config/asciinema</code>.</p>"},{"location":"manual/cli/configuration/v3/","title":"CLI 3.0+ configuration","text":""},{"location":"manual/cli/configuration/v3/#config-file","title":"Config file","text":"<p>You can configure asciinema CLI 3.0+ by creating a config file at <code>$HOME/.config/asciinema/config.toml</code>. A system-wide config file at <code>/etc/asciinema/config.toml</code> may also be used to set defaults for all users.</p> <p>Here's an overview of all available options for each configuration section.</p> ~/.config/asciinema/config.toml<pre><code>[server]\n\n# asciinema server URL\n# If you run your own instance of asciinema server then set its address here\n# It can also be overridden by setting ASCIINEMA_SERVER_URL environment variable\nurl = \"https://asciinema.example.com\"\n\n[session]\n# This section applies to commands that start a new shell session, i.e. `rec`,\n# `stream` and `session`.\n\n# Command to record, default: $SHELL\ncommand = \"/bin/bash -l\"\n\n# Enable input (keyboard) recording, default: false\ncapture_input = true\n\n# List of environment variables to capture, default: SHELL\ncapture_env = \"SHELL,TERM,USER\"\n\n# Limit recorded terminal inactivity to max n seconds, default: off\nidle_time_limit = 2\n\n# Define hotkey for pausing recording (suspending capture of output),\n# default: ^\\ (control + backslash)\npause_key = \"^p\"\n\n# Define hotkey for adding a marker, default: none\nadd_marker_key = \"^x\"\n\n# Define hotkey prefix key - when defined other recording hotkeys must\n# be preceded by it, default: no prefix\nprefix_key = \"^a\"\n\n[playback]\n\n# Playback speed (can be fractional), default: 1\nspeed = 2\n\n# Limit replayed terminal inactivity to max n seconds, default: off\nidle_time_limit = 1\n\n# Define hotkey for pausing/resuming playback,\n# default: space\npause_key = \"p\"\n\n# Define hotkey for stepping through playback, a frame at a time,\n# default: . (dot)\nstep_key = \"s\"\n\n# Define hotkey for jumping to the next marker,\n# default: ]\nnext_marker_key = \"m\"\n\n[notifications]\n# Desktop notifications are displayed in several situations, e.g. when\n# pausing/resuming the capture of terminal with ^\\ keyboard shortcut.\n\n# Should desktop notifications be enabled, default: true\nenabled = false\n\n# Custom notification command\n# asciinema automatically detects available desktop notification system\n# (notify-send on GNU/Linux, osacript on macOS). Custom command can be\n# used if needed.\n# When invoked, environment variable $TEXT contains notification text.\ncommand = 'tmux display-message \"$TEXT\"'\n</code></pre> <p>A minimal config file could look like this:</p> <pre><code>[session]\nidle_time_limit = 2\n</code></pre>"},{"location":"manual/cli/configuration/v3/#environment-variables","title":"Environment variables","text":""},{"location":"manual/cli/configuration/v3/#asciinema_server_url","title":"<code>ASCIINEMA_SERVER_URL</code>","text":"<p>Specifies base URL of an asciinema server, used for uploading of recordings and live streaming.</p> <p>This value can also be set in the config file as <code>server.url</code>.</p> <p>If you self-host asciinema server then you should set the server URL to its base URL, e.g. <code>https://asciinema.example.com</code>.</p>"},{"location":"manual/cli/configuration/v3/#asciinema_config_home","title":"<code>ASCIINEMA_CONFIG_HOME</code>","text":"<p>Specifies config directory path.</p> <p>Defaults to <code>$XDG_CONFIG_HOME/asciinema</code> if <code>XDG_CONFIG_HOME</code> is set, otherwise defaults to <code>$HOME/.config/asciinema</code>.</p>"},{"location":"manual/cli/configuration/v3/#asciinema_state_home","title":"<code>ASCIINEMA_STATE_HOME</code>","text":"<p>Specifies state directory path.</p> <p>Defaults to <code>$XDG_STATE_HOME/asciinema</code> if <code>XDG_STATE_HOME</code> is set, otherwise defaults to <code>$HOME/.local/state/asciinema</code>.</p>"},{"location":"manual/player/","title":"asciinema player","text":"<p>asciinema player is a web player for terminal session recordings.</p> <p>Unlike typical web video players, which play heavyweight video files (<code>.mp4</code>, <code>.mov</code>), asciinema player plays lightweight terminal session recordings in the text-based asciicast format (<code>.cast</code>), such as those produced by asciinema recorder.</p> <p>The player is built from the ground up with JavaScript and Rust (WASM), and is available as npm package and a standalone JS bundle.</p> <p>You can use it on any HTML page - in a project documentation, on a blog, or in a conference talk presentation.</p> <p>It's as easy as adding a single line of Javascript code to your web page:</p> <pre><code>AsciinemaPlayer.create('demo.cast', document.getElementById('demo'));\n</code></pre> <p>Check out the quick start guide for basic setup overview.</p> <p>Notable features:</p> <ul> <li>playback of static recordings and live terminal streams,</li> <li>ability to copy-paste terminal content - it's just text after all!</li> <li>smooth, timing-accurate playback,</li> <li>idle time optimization to skip periods of   inactivity,</li> <li>posters,</li> <li>markers for navigation or auto-pause,</li> <li>configurable font families and line   height,</li> <li>automatic terminal scaling to fit into container element in   most efficient way,</li> <li>full-screen mode,</li> <li>multiple color themes for standard 16 colors + support for   256 color palette and 24-bit true color (ISO-8613-3),</li> <li>adjustable playback speed,</li> <li>looped playback, infinite or finite,</li> <li>starting playback at specific time,</li> <li>API for programmatic control,</li> <li>keyboard shortcuts,</li> <li>support for other recording   formats like ttyrec, typescript.</li> </ul> <p>asciinema player is free and open-source software (FOSS). Source code and license available at github.com/asciinema/asciinema-player.</p>"},{"location":"manual/player/api/","title":"API","text":"<p>asciinema player provides <code>AsciinemaPlayer</code> module, which exports <code>create</code> function for adding the player to a page.</p> <p>The player object, returned by <code>create</code> function, provides several methods that can be used to control the player or obtain information about its state.</p> <p>Check Installation section for instructions on making the module available to your code.</p>"},{"location":"manual/player/api/#mounting-in-dom","title":"Mounting in DOM","text":"<p>Add the player to a page with:</p> <pre><code>AsciinemaPlayer.create(src, containerElement, opts);\n</code></pre> <p>The arguments are:</p> <ul> <li><code>src</code> - recording source, typically a recording URL,</li> <li><code>containerElement</code> - container DOM element, to mount the player in,</li> <li><code>opts</code> - configuration options (optional)</li> </ul> <p>For example, to mount the player inside <code>demo</code> element and use idleTimeLimit option do this:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  idleTimeLimit: 2\n});\n</code></pre> <p>See Loading a recording learn about various ways of getting a recording into the player.</p> <p>See Options for a complete list of available options.</p>"},{"location":"manual/player/api/#control-inspection","title":"Control &amp; inspection","text":"<p>To control the player programmatically, assign the return value of <code>AsciinemaPlayer.create</code> to a variable. Then use any of the control methods like this:</p> <pre><code>const player = AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'));\n\nplayer.play().then(() =&gt; {\n  console.log(`started! duration: ${player.getDuration()}`);\n});\n</code></pre> <p>Here goes a complete list of available methods exposed by the player:</p>"},{"location":"manual/player/api/#getcurrenttime","title":"<code>getCurrentTime()</code>","text":"<p>Returns the current playback time in seconds.</p> <pre><code>player.getCurrentTime(); // =&gt; 1.23\n</code></pre>"},{"location":"manual/player/api/#getduration","title":"<code>getDuration()</code>","text":"<p>Returns the length of the recording in seconds, or <code>null</code> if the recording is not loaded yet.</p> <pre><code>player.getDuration(); // =&gt; 123.45\n</code></pre>"},{"location":"manual/player/api/#play","title":"<code>play()</code>","text":"<p>Initiates playback of the recording. If the recording hasn't been preloaded then it's loaded, and playback is started.</p> <pre><code>player.play();\n</code></pre> <p>This function returns a promise which is fulfilled when the playback actually starts.</p> <pre><code>player.play().then(() =&gt; {\n  console.log(`started! duration: ${player.getDuration()}`);\n});\n</code></pre> <p>If you want to synchronize asciinema player with other elements on the page, e.g.  audio HTML element, then you can use this promise for coordination. Alternatively you can add event listener for play / playing events (see below).</p>"},{"location":"manual/player/api/#pause","title":"<code>pause()</code>","text":"<p>Pauses playback.</p> <pre><code>player.pause();\n</code></pre> <p>The playback is paused immediately.</p>"},{"location":"manual/player/api/#seeklocation","title":"<code>seek(location)</code>","text":"<p>Changes the playback location to specified time or marker.</p> <p><code>location</code> argument can be:</p> <ul> <li>time in seconds, as number, e.g. <code>15</code></li> <li>position in percentage, as string, e.g <code>'50%'</code></li> <li>specific marker by its 0-based index, as <code>{ marker: i }</code> object, e.g. <code>{ marker: 3 }</code></li> <li>previous marker, as <code>{ marker: 'prev' }</code> object,</li> <li>next marker, as <code>{ marker: 'next' }</code> object.</li> </ul> <p>This function returns a promise which is fulfilled when the location actually changes.</p> <pre><code>player.seek(15).then(() =&gt; {\n  console.log(`current time: ${player.getCurrentTime()}`);\n});\n</code></pre>"},{"location":"manual/player/api/#addeventlistenereventname-handler","title":"<code>addEventListener(eventName, handler)</code>","text":"<p>Adds event listener, binding handler's <code>this</code> to the player object.</p> <p>See Events below for the list of all supported events.</p>"},{"location":"manual/player/api/#dispose","title":"<code>dispose()</code>","text":"<p>Use this function to dispose of the player, i.e. to shut it down, release all resources and remove it from DOM.</p>"},{"location":"manual/player/api/#events","title":"Events","text":"<p>The following events are dispatched by the player during the playback. You can react to them by attaching event listeners with addEventListener.</p>"},{"location":"manual/player/api/#play-event","title":"<code>play</code> event","text":"<p><code>play</code> event is dispatched when playback is initiated, either by clicking play button or calling <code>player.play()</code> method, but not yet started.</p> <pre><code>player.addEventListener('play', () =&gt; {\n  console.log('play!');\n})\n</code></pre> <p>Info</p> <p>There's subtle difference between the <code>play</code> event and the <code>playing</code> event (below). If the recording is not preloaded (default behaviour) then <code>play</code> is triggered when the player initiates the playback and starts fetching the recording. In other words, <code>play</code> signals the intent of playback. <code>playing</code> signals the actual start.</p>"},{"location":"manual/player/api/#playing-event","title":"<code>playing</code> event","text":"<p><code>playing</code> event is dispatched when playback actually starts or resumes from pause.</p> <pre><code>player.addEventListener('playing', () =&gt; {\n  console.log(`playing! we're at: ${this.getCurrentTime()}`);\n})\n</code></pre>"},{"location":"manual/player/api/#pause-event","title":"<code>pause</code> event","text":"<p><code>pause</code> event is dispatched when playback is paused.</p> <pre><code>player.addEventListener('pause', () =&gt; {\n  console.log(\"paused!\");\n})\n</code></pre>"},{"location":"manual/player/api/#ended-event","title":"<code>ended</code> event","text":"<p><code>ended</code> event is dispatched when playback stops after reaching the end of the recording.</p> <pre><code>player.addEventListener('ended', () =&gt; {\n  console.log(\"ended!\");\n})\n</code></pre>"},{"location":"manual/player/api/#input-event","title":"<code>input</code> event","text":"<p><code>input</code> event is dispatched for every keyboard input that was recorded.</p> <p>Callback's 1st argument is an object with <code>data</code> field, which contains registered input value. Usually this is ASCII character representing a key, but may be a control character, like <code>\"\\r\"</code> (enter), <code>\"\\u0001\"</code> (ctrl-a), <code>\"\\u0003\"</code> (ctrl-c), etc. See input event in asciicast file format for more information.</p> <pre><code>player.addEventListener('input', ({ data }) =&gt; {\n  console.log('input!', JSON.stringify(data));\n})\n</code></pre> <p>This event can be used for example to play keyboard typing sound, or display key presses on the screen.</p> <p>Note</p> <p><code>input</code> events are available only for asciicasts recorded with <code>--stdin</code> option, i.e. <code>asciinema rec --stdin &lt;filename&gt;</code>.</p> <p>Experimental <code>inputOffset</code> driver option can be used to shift triggering of input events in time, e.g. when you need them to fire earlier due to audio sample latency.</p> <p>Say, you want to play Cherry MX Brown (eeewww!) sound for each key press.</p> <pre><code>const player = AsciinemaPlayer.create({\n  url: '/demo.cast',\n  inputOffset: -0.125\n}, document.getElementById('demo'));\n\nplayer.addEventListener('input', ({ data }) =&gt; {\n  // this is fired 125 milliseconds ahead of the original key press time\n  playSound(data);\n})\n</code></pre> <p>Below is the result. Make sure your audio is not on mute.</p> <p>Note</p> <p><code>inputOffset</code> is a driver option. Driver options are options specific to each driver, and they must be passed in <code>create</code>'s first argument, together with a URL. <code>inputOffset</code> is an option of the recording driver.</p> <p>Concept of drivers is not fully finalized yet and is subject to change. Feel free to check the source code of currently available drivers for what options are available. Be warned though: drivers other than the default recording one are experimental and may change in the future.</p>"},{"location":"manual/player/api/#marker-event","title":"<code>marker</code> event","text":"<p><code>marker</code> event is dispatched for every marker encountered during playback.</p> <p>Callback's 1st argument is an object with <code>index</code>, <code>time</code> and <code>label</code> fields, which represent marker's index (0-based), time and label respectively.</p> <pre><code>player.addEventListener('marker', ({ index, time, label }) =&gt; {\n  console.log(`marker! ${index} - ${time} - ${label}`);\n})\n</code></pre> <p>This event can be used for orchestrating arbitrary, timed actions on your page outside of the player, as well as for fine-grained playback control, e.g. implementing looping over a section of a recording.</p>"},{"location":"manual/player/fonts/","title":"Fonts","text":"<p>By default the player uses a web safe, platform specific monospace font with <code>font-family</code> value like this: <code>\"Consolas, Menlo, 'Bitstream Vera Sans Mono', monospace\"</code>.</p> <p>You can use any custom monospace font with the player by adding <code>@font-face</code> definitions in CSS and calling <code>AsciinemaPlayer.create</code> with terminalFontFamily option. Regular font face is necessary, bold (weight 700) is recommended, italic is optional (italics are rarely used in terminal).</p> <p>If you use icons or other symbols in your shell you may want to use one of the Nerd Fonts variants.</p> <p>Here's an example of using Fira Code Nerd Font:</p> app.css<pre><code>@font-face {\n    font-family: \"FiraCode Nerd Font\";\n    src:    local(Fira Code Bold Nerd Font Complete Mono),\n            url(\"/fonts/Fira Code Bold Nerd Font Complete Mono.ttf\") format(\"truetype\");\n    font-stretch: normal;\n    font-style: normal;\n    font-weight: 700;\n}\n\n@font-face {\n    font-family: \"FiraCode Nerd Font\";\n    src:    local(Fira Code Regular Nerd Font Complete Mono),\n            url(\"/fonts/Fira Code Regular Nerd Font Complete Mono.ttf\") format(\"truetype\");\n    font-stretch: normal;\n}\n</code></pre> app.js<pre><code>document.fonts.load(\"1em FiraCode Nerd Font\").then(() =&gt; {\n  AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n    terminalFontFamily: \"'FiraCode Nerd Font', monospace\"\n  });\n}\n</code></pre> <p>Note</p> <p>The player performs measurement of font metrics (width/height) when it mounts in the page, therefore it's highly recommended to ensure chosen font is already loaded before calling <code>create</code>. This can be achieved by using CSS Font Loading API as seen in the above example.</p> <p>If you know that your audience has the desired font already installed on their systems, e.g. when you choose a font that comes preinstalled with an OS, then you may try without using <code>document.fonts.load()</code>.</p>"},{"location":"manual/player/loading/","title":"Loading a recording","text":"<p>While the easiest way of loading a recording into the player is by using asciicast file URL, it's also easy to customize the loading procedure or even replace it completely.</p>"},{"location":"manual/player/loading/#preloading","title":"Preloading","text":"<p>By default the player doesn't fetch a recording upon initialization, postponing the loading until user starts the playback. Given how small (in terms of filesize) terminal recordings are this usually is perfectly fine. However, if you wish so you can force the player to preload the recording upon its initialization using the preload option:</p> <pre><code>AsciinemaPlayer.create(src, containerElement, { preload: true });\n</code></pre>"},{"location":"manual/player/loading/#custom-fetch-options","title":"Custom <code>fetch</code> options","text":"<p>If you'd like to fetch a recording from a URL, but you need to tweak how HTTP request is performed (e.g. configure credentials, change HTTP method), you can do so by using <code>{ url: \"...\", fetchOpts: { ... } }</code> object as the source argument.  <code>fetchOpts</code> object is then passed to fetch (as its 2nd argument).</p> <p>For example:</p> <pre><code>AsciinemaPlayer.create(\n  { url: url, fetchOpts: { method: 'POST' } },\n  containerElement\n);\n</code></pre>"},{"location":"manual/player/loading/#inlining-with-data-url","title":"Inlining with Data URL","text":"<p>If a recording file is small and you'd rather avoid additional HTTP request, you can inline the recording by using Data URL:</p> <pre><code>AsciinemaPlayer.create(\n  'data:text/plain;base64,' + base64encodedAsciicast,\n  containerElement\n);\n</code></pre> <p>For example:</p> <pre><code>AsciinemaPlayer.create(\n  'data:text/plain;base64,eyJ2ZXJzaW9uIjogMiwgIndpZHRoIjogODAsICJoZWlnaHQiOiAyNH0KWzAuMSwgIm8iLCAiaGVsbCJdClswLjUsICJvIiwgIm8gIl0KWzIuNSwgIm8iLCAid29ybGQhXG5cciJdCg==',\n  document.getElementById('demo')\n);\n</code></pre> <p>This approach is useful e.g. when you're dynamically generating HTML on the server-side, embedding player initialization code in HTML of the page.</p>"},{"location":"manual/player/loading/#dynamic-loading","title":"Dynamic loading","text":"<p>If you prefer to provide a recording to the player manually at runtime you can use the following variant of the <code>src</code> argument with the <code>create</code> function:</p> <pre><code>AsciinemaPlayer.create({ data: data }, containerElement);\n</code></pre> <p>The value of <code>data</code> can be:</p> <ul> <li>a string containing asciicast in v3, v2 or v1 format</li> <li>an array representing asciicast in v3 or v2 format</li> <li>an object representing asciicast in v1 format</li> <li>a function which returns one of the above (may be async)</li> </ul> <p>Provided <code>data</code> is parsed with built-in asciicast format parser by default (also see Playing other recording formats below).</p> <p>Examples of supported <code>data</code> specifications:</p> <pre><code>// string representing asciicast in v2 format (ndjson)\n'{\"version\": 2, \"width\": 80, \"height\": 24}\\n[1.0, \"o\", \"hello \"]\\n[2.0, \"o\", \"world!\"]';\n</code></pre> <pre><code>// string representing asciicast in v1 format (json)\n'{\"version\": 1, \"width\": 80, \"height\": 24, \"stdout\": [[1.0, \"hello \"], [1.0, \"world!\"]]}';\n</code></pre> <pre><code>// array representing asciicast in v2 format\n[\n  {version: 2, width: 80, height: 24},\n  [1.0, \"o\", \"hello \"],\n  [2.0, \"o\", \"world!\"]\n]\n</code></pre> <pre><code>// object representing asciicast in v1 format\n{version: 1, width: 80, height: 24, stdout: [[1.0, \"hello \"], [1.0, \"world!\"]]};\n</code></pre> <pre><code>// function returning a string representing asciicast in v2 format (ndjson)\n() =&gt; '{\"version\": 2, \"width\": 80, \"height\": 24}\\n[1.0, \"o\", \"hello \"]\\n[2.0, \"o\", \"world!\"]';\n</code></pre> <p>Passing asciicast v2 as a string looks like this:</p> <pre><code>AsciinemaPlayer.create(\n  { data: '{\"version\": 2, \"width\": 80, \"height\": 24}\\n[1.0, \"o\", \"hello \"]\\n[2.0, \"o\", \"world!\"]' },\n  document.getElementById('demo')\n);\n</code></pre> <p>Similarly to inlining with Data URL this is useful for server-side generation use-cases.</p> <p>If <code>data</code> is a function, then the player invokes it when playback is started by a user. If preload option is used, the function is invoked during player initialization (mounting in DOM).</p> <p>Say you'd like to embed asciicast contents in a (hidden) HTML tag on your page, following data source can be used to extract it and pass it to the player:</p> <pre><code>AsciinemaPlayer.create(\n  { data: () =&gt; document.getElementById('asciicast').textContent.trim() },\n  document.getElementById('demo')\n);\n</code></pre> <p>Finally, you can call <code>fetch</code> yourself and transform the result:</p> <pre><code>AsciinemaPlayer.create(\n  { data: () =&gt; fetch(url, { method: 'POST' }).then(...) },\n  containerElement\n);\n</code></pre> <p>This is handy e.g. when you need to extract an asciicast from a nested JSON structure produced by HTTP API.</p> <p>Note</p> <p>You can fetch the recording first and only then initialize the player with <code>{ data: '...' }</code>, like this:</p> <pre><code>fetch('/demo.cast').then(resp =&gt; {\n  AsciinemaPlayer.create({ data: resp }, document.getElementById('demo'));\n});\n</code></pre> <p>However this has a downside: the player is not added to the page until the data is loaded, resulting in the player poping up on the page out of nowhere a moment after the page load.</p> <p>By using <code>{ data: () =&gt; ... }</code> (function variant) you can mount the player on the page immediately.</p>"},{"location":"manual/player/loading/#playing-other-recording-formats","title":"Playing other recording formats","text":"<p>By default, recordings are parsed with a built-in asciicast format parser.</p> <p>If you have a recording produced by other terminal session recording tool (e.g. script, termrec, ttyrec) you can use one of built-in file format parsers, or implement a custom parser function.</p> <p>Recording format parser can be specified in the source argument to <code>AsciinemaPlayer.create</code> as a string (built-in) or a function (custom):</p> <pre><code>AsciinemaPlayer.create({ url: url, parser: parser }, containerElement);\n</code></pre> <p>See Parsers for information on available built-in parsers and how to implement a custom one.</p>"},{"location":"manual/player/loading/#playing-live-streams","title":"Playing live streams","text":"<p>In addition to loading static asciicast files, the asciinema player supports connecting to live WebSocket streams for real-time terminal session viewing. This enables viewers to watch terminal sessions as they happen, with minimal latency (typically below 100ms).</p> <p>To connect the player to a live WebSocket stream:</p> <pre><code>AsciinemaPlayer.create(\n  'ws://example.com/stream',\n  document.getElementById('demo')\n);\n</code></pre> <p>For example, asciinema server provides consumer endpoint for live streams at <code>/ws/s/&lt;public-token&gt;</code>. This is how the player hosted at asciinema.org connects to a stream:</p> <pre><code>AsciinemaPlayer.create(\n  'wss://asciinema.org/ws/s/&lt;public-token&gt;',\n  document.getElementById('demo')\n);\n</code></pre> <p>Player's WebSocket driver, activated by use of <code>ws://</code> or <code>wss://</code> scheme, automatically handles stream protocol negotiation, uses adaptive buffering to achieve lowest possible latency, and gracefully handles disconnections (reconnect with backoff + jitter).</p> <p>For detailed information about implementing WebSocket streaming servers, including complete protocol specifications and message formats, see the Live streaming in the server manual.</p>"},{"location":"manual/player/markers/","title":"Markers","text":"<p>Markers are specific points on a recording's timeline, which can be used for navigation within the recording or to automate the player.</p> <p>Each marker is defined by its time and can have an optional label.</p> <p>The player displays markers as dots inside the progress bar in the bottom part of the UI. When hovered, a marker shows the time and the label. Clicking on a marker moves the playback to its corresponding time position.</p> <p>Markers are useful for defining chapters, or any points of interest, as well as act as breakpoints. They can be reacted on by listening for <code>marker</code> event, and they can also be used for programmatic seek.</p> <p>There two ways of specifying markers for use in the player:</p> <ul> <li>using <code>markers</code> option,</li> <li>embedding markers in the recording - see Markers in the   CLI section for details.</li> </ul>"},{"location":"manual/player/markers/#setting-markers","title":"Setting markers","text":"<p>The easiest way of setting markers is by using <code>markers</code> option.</p> <p>Example of setting unlabeled markers:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  markers: [5.0, 25.0, 66.6, 176.5]  // time in seconds\n});\n</code></pre> <p>Example of setting labeled markers:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  markers: [\n    [5.0,   \"Installation\"],  // time in seconds + label\n    [25.0,  \"Configuration\"],\n    [66.6,  \"Usage\"],\n    [176.5, \"Tips &amp; Tricks\"]\n  ]\n});\n</code></pre> <p>If you keep your recordings on asciinema.org or you self-host the server you can set markers on recording settings page.</p> <p>Another way of defining markers is by embedding them directly in a recording. Note the lines with <code>m</code> code - those are marker definitions:</p> example.cast<pre><code>{\"version\": 2, \"width\": 80, \"height\": 24, \"timestamp\": 1700000000}\n[0.248848, \"o\", \"...\"]\n[1.001376, \"o\", \"...\"]\n[1.500000, \"m\", \"Intro\"]\n[2.143733, \"o\", \"...\"]\n[5.758989, \"o\", \"...\"]\n[6.000000, \"m\", \"Installation\"]\n[7.543289, \"o\", \"...\"]\n[8.625739, \"o\", \"...\"]\n[15.000000, \"m\", \"Usage\"]\n[16.643287, \"o\", \"...\"]\n[17.389425, \"o\", \"...\"]\n</code></pre> <p>asciinema recorder can be configured to have a keyboard shortcut for adding markers during the recording session. If you have an existing recording you can edit the file with your favourite editor and insert marker lines as shown in the above example.</p>"},{"location":"manual/player/markers/#markers-as-breakpoints","title":"Markers as breakpoints","text":"<p>Markers can be configured to act as breakpoints, i.e. automatically pause the playback when reached.</p> <p>Start the playback below and observe the player pausing as it reaches each marker.</p> <p>This behaviour can be enabled with pauseOnMarkers option.</p>"},{"location":"manual/player/markers/#marker-event","title":"<code>marker</code> event","text":"<p>When the player encounters a marker during the playback it dispatches a <code>marker</code> event.</p> <p>You can use it to react to a marker any way you want. Here we manually implement breakpoints by pausing the player using its API:</p> <pre><code>player.addEventListener('marker', _marker =&gt; {\n  player.pause();\n})\n</code></pre>"},{"location":"manual/player/markers/#seeking-to-a-marker","title":"Seeking to a marker","text":"<p>Markers can also be used as a seek target.</p> <p>You can seek to next, previous or a specific marker:</p> <pre><code>// seek to next marker\nplayer.seek({ marker: 'next' });\n\n// seek to previous marker\nplayer.seek({ marker: 'prev' });\n\n// seek to a marker with index 2\nplayer.seek({ marker: 2 });\n</code></pre> <p>The following example shows how to implement looping over a section of a recording by combining <code>marker</code> event with <code>seek</code> method:</p> <pre><code>player.addEventListener('marker', ({ index, time, label }) =&gt; {\n  console.log(`marker! ${index} - ${time} - ${label}`);\n\n  if (index == 1) {\n    player.seek({ marker: 0 });\n  }\n})\n</code></pre> <p>Here's the result:</p>"},{"location":"manual/player/markers/#keyboard-navigation","title":"Keyboard navigation","text":"<p>The following keyboard shortcuts can be used to navigate between markers when the player element has input focus:</p> <ul> <li>[ (left square bracket) - rewind to the previous marker</li> <li>] (right square bracket) - fast-forward to the next marker</li> </ul>"},{"location":"manual/player/options/","title":"Options","text":"<p>Look and feel of the asciinema player can be configured extensively by passing additional options when mounting the player on the page.</p> <p>For example, setting double speed while limiting idle time to 2 seconds can be configure like this:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  speed: 2,\n  idleTimeLimit: 2,\n});\n</code></pre> <p>Below you can find all available options.</p>"},{"location":"manual/player/options/#cols","title":"<code>cols</code>","text":"<p>Type: number</p> <p>Width of player's terminal in columns.</p> <p>When not set it defaults to 80 (until asciicast gets loaded) and to terminal width saved in the asciicast file (after it gets loaded).</p> <p>It's recommended to set it to the same value as in asciicast file to avoid player resizing itself from 80x24 to actual dimensions of the recording when it gets loaded.</p>"},{"location":"manual/player/options/#rows","title":"<code>rows</code>","text":"<p>Type: number</p> <p>Height of player's terminal in rows (lines).</p> <p>When not set it defaults to 24 (until asciicast gets loaded) and to terminal height saved in the asciicast file (after it gets loaded).</p> <p>Same recommendation as for <code>cols</code> applies here.</p>"},{"location":"manual/player/options/#autoplay","title":"<code>autoPlay</code>","text":"<p>Type: boolean</p> <p>Set this option to <code>true</code> if the playback should start automatically.</p> <p>Defaults to <code>false</code> - no auto play.</p>"},{"location":"manual/player/options/#preload","title":"<code>preload</code>","text":"<p>Type: boolean</p> <p>Set this option to <code>true</code> if the recording should be preloaded on player's initialization.</p> <p>Defaults to <code>false</code> - no preload.</p> <p>Tip</p> <p>Check Loading a recording for available options of getting a recording into the player in the most suitable way.</p>"},{"location":"manual/player/options/#loop","title":"<code>loop</code>","text":"<p>Type: boolean or number</p> <p>Set this option to either <code>true</code> or a number if playback should be looped. When set to a number (e.g. <code>3</code>) then the recording will be re-played given number of times and stopped after that.</p> <p>Defaults to <code>false</code> - no looping.</p>"},{"location":"manual/player/options/#startat","title":"<code>startAt</code>","text":"<p>Type: number or string</p> <p>Start the playback at a given time.</p> <p>Supported formats:</p> <ul> <li><code>123</code> (number of seconds)</li> <li><code>\"2:03\"</code> (\"mm:ss\")</li> <li><code>\"1:02:03\"</code> (\"hh:mm:ss\")</li> </ul> <p>Defaults to <code>0</code>.</p>"},{"location":"manual/player/options/#speed","title":"<code>speed</code>","text":"<p>Type: number</p> <p>Playback speed. The value of <code>2</code> means 2x faster.</p> <p>Defaults to <code>1</code> - normal speed.</p>"},{"location":"manual/player/options/#idletimelimit","title":"<code>idleTimeLimit</code>","text":"<p>Type: number</p> <p>Limit terminal inactivity to a given number of seconds.</p> <p>For example, when set to <code>2</code> any inactivity (pauses) longer than 2 seconds will be \"compressed\" to 2 seconds.</p> <p>Defaults to:</p> <ul> <li><code>idle_time_limit</code> from asciicast header (saved when passing <code>-i &lt;sec&gt;</code> to   <code>asciinema rec</code>),</li> <li>no limit, when it was not specified at the time of recording.</li> </ul> <p>Tip</p> <p>This option makes the playback more pleasant for viewers, therefore it's recommended to use it in most cases. It's often better to use <code>idleTimeLimit</code> than <code>speed</code>. You can use both together too!</p>"},{"location":"manual/player/options/#theme","title":"<code>theme</code>","text":"<p>Type: string</p> <p>Terminal color theme.</p> <p>asciinema CLI 3.0 (and later) captures original terminal theme and embeds it in a recording file. This lets the player replicate the exact colors by default.</p> <p>This option can be used to override the terminal theme. See Terminal themes for a list of available built-in themes (also how to use a custom theme).</p> <p>If you'd like to configure the player to use the original theme when available, falling back to a specific theme, e.g. <code>dracula</code>, then prefix the theme name with <code>auto/</code>. For example: <code>{ theme: \"auto/dracula\" }</code>.</p> <p>Defaults to <code>\"auto/asciinema\"</code> since player v3.8, and to <code>\"asciinema\"</code> in earlier versions.</p>"},{"location":"manual/player/options/#poster","title":"<code>poster</code>","text":"<p>Type: string</p> <p>Poster (a preview frame) to display until the playback is started.</p> <p>The following poster specifications are supported:</p> <ul> <li><code>npt:1:23</code> - display recording \"frame\" at given time using NPT (\"Normal Play Time\") notation</li> <li><code>data:text/plain,Poster text</code> - print given text</li> </ul> <p>The easiest way of specifying a poster is to use NPT format. For example, <code>npt:1:23</code> will preload the recording and display terminal contents at 1 min 23 sec.</p> <p>Example:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  poster: 'npt:1:23'\n});\n</code></pre> <p>Note</p> <p>Using NPT-based poster preloads the recording on player's initialization regardless of preload option value.</p> <p>Alternatively, a <code>poster</code> value of <code>data:text/plain,This will be printed as poster\\n\\rThis in second line</code> will display arbitrary text. All ANSI escape codes can be used to add color and move the cursor around to produce good looking poster.</p> <p>Example of using custom text poster with control sequences (aka escape codes):</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  poster: \"data:text/plain,I'm regular \\x1b[1;32mI'm bold green\\x1b[3BI'm 3 lines down\"\n});\n</code></pre> <p>Defaults to blank terminal or, when <code>startAt</code> is specified, to screen contents at time specified by <code>startAt</code>.</p>"},{"location":"manual/player/options/#audiourl","title":"<code>audioUrl</code>","text":"<p>Type: string (URL)</p> <p>Audio file/stream to play together with the terminal session.</p> <p>For recorded sessions (asciicast files) the audio position is automatically synced with the session playback - pausing/resuming/seeking is reflected in the audio playback.</p> <p>For live terminal streams <code>audioUrl</code> is expected to be a live audio source - either a direct HTTP audio stream (.mp3, .aac, .ogg, etc) such as Icecast/Shoutcast endpoint, or HLS playlist (.m3u8).</p> <p>Example:</p> asciicast file with audio track<pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  audioUrl: '/demo.mp3'\n});\n</code></pre> Live terminal stream with live audio source<pre><code>AsciinemaPlayer.create('ws://example.com/stream', document.getElementById('demo'), {\n  audioUrl: 'http://example.com/icecast/stream.ogg'\n});\n</code></pre> <p>Tip</p> <p>Ensure the audio endpoint is configured to allow CORS requests from the server providing the audio file/stream.</p> <p>Warning</p> <p>When using <code>audioUrl</code> don't use <code>autoplay: true</code>. Browsers often require explicit user action, such as click/tap, right before the audio playback can start. With <code>autoplay: true</code> the audio is unlikely to play due to lack of user action.</p>"},{"location":"manual/player/options/#fit","title":"<code>fit</code>","text":"<p>Type: string</p> <p>Selects fitting (sizing) behaviour with regards to player's container element.</p> <p>Possible values:</p> <ul> <li><code>\"width\"</code> - scale to full width of the container</li> <li><code>\"height\"</code> - scale to full height of the container (requires the container element to have fixed height)</li> <li><code>\"both\"</code> - scale to either full width or height, maximizing usage of available space (requires the container element to have fixed height)</li> <li><code>false</code> / <code>\"none\"</code> - don't scale, use fixed size font (also see <code>fontSize</code> option below)</li> </ul> <p>Defaults to <code>\"width\"</code>.</p> <p>Note</p> <p>Version 2.x of the player supported only the behaviour of the <code>false</code> value. If you're [upgrading from v2 to v3](upgrading.md and want to preserve the old sizing behaviour then include <code>fit: false</code> option.</p>"},{"location":"manual/player/options/#controls","title":"<code>controls</code>","text":"<p>Type: boolean or \"auto\"</p> <p>Hide or show user controls, i.e. bottom control bar.</p> <p>Valid values:</p> <ul> <li><code>true</code> - always show controls</li> <li><code>false</code> - never show controls</li> <li><code>\"auto\"</code> - show controls on mouse movement, hide on lack of mouse movement</li> </ul> <p>Defaults to <code>\"auto\"</code>.</p>"},{"location":"manual/player/options/#markers","title":"<code>markers</code>","text":"<p>Type: array</p> <p>Defines a list of timeline markers.</p> <p>Example of unlabeled markers:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  markers: [5.0, 25.0, 66.6, 176.5]  // time in seconds\n});\n</code></pre> <p>Example of labeled markers:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  markers: [\n    [5.0,   \"Installation\"],  // time in seconds + label\n    [25.0,  \"Configuration\"],\n    [66.6,  \"Usage\"],\n    [176.5, \"Tips &amp; Tricks\"]\n  ]\n});\n</code></pre> <p>Markers set with this option override all markers embedded in asciicast files. If this option is not set the player defaults to markers found in the recording file (if any).</p> <p>Markers overview provides more information on using markers.</p>"},{"location":"manual/player/options/#pauseonmarkers","title":"<code>pauseOnMarkers</code>","text":"<p>Type: boolean</p> <p>If <code>pauseOnMarkers</code> is set to <code>true</code>, the playback automatically pauses on every marker encountered and it can be resumed by either pressing the space bar key or clicking on the play button. The resumed playback continues until the next marker is encountered.</p> <p>This option can be useful in e.g. live demos: you can add markers to a recording, then play it back during presentation, and have the player stop wherever you want to explain terminal contents in more detail.</p> <p>Defaults to <code>false</code>.</p>"},{"location":"manual/player/options/#terminalfontsize","title":"<code>terminalFontSize</code>","text":"<p>Type: string</p> <p>Size of the terminal font.</p> <p>Possible values:</p> <ul> <li>any valid CSS <code>font-size</code> value, e.g. <code>\"15px\"</code></li> <li><code>\"small\"</code></li> <li><code>\"medium\"</code></li> <li><code>\"big\"</code></li> </ul> <p>Defaults to <code>\"small\"</code>.</p> <p>Warning</p> <p>This option is effective only when <code>fit: false</code> option is specified as well (see above).</p>"},{"location":"manual/player/options/#terminalfontfamily","title":"<code>terminalFontFamily</code>","text":"<p>Type: string</p> <p>Terminal font-family override.</p> <p>Use any valid CSS <code>font-family</code> value, e.g <code>\"'JetBrains Mono', Consolas, Menlo, 'Bitstream Vera Sans Mono', monospace\"</code>.</p> <p>Note</p> <p>If you want to use web fonts, see the Fonts section for information on the best way to load them to ensure the player initializes properly.</p>"},{"location":"manual/player/options/#terminallineheight","title":"<code>terminalLineHeight</code>","text":"<p>Type: number</p> <p>Terminal line height override.</p> <p>The value is relative to the font size (like <code>em</code> unit in CSS). For example a value of <code>1</code> makes the line height equal to the font size, leaving no space between lines. A value of <code>2</code> makes it double the font size, etc.</p> <p>Defaults to <code>1.33333333</code>.</p>"},{"location":"manual/player/options/#logger","title":"<code>logger</code>","text":"<p>Type: console-like object</p> <p>Set this option to <code>console</code>, i.e. <code>{ logger: console }</code>, or any object implementing console API (<code>.log()</code>, <code>.debug()</code>, <code>.info()</code>, <code>.warn()</code>, <code>.error()</code> methods) to enable logging. Useful during development or when debugging player issues.</p>"},{"location":"manual/player/parsers/","title":"Parsers","text":"<p>Parser is a function, which transforms a recording encoded in an arbitrary file format into a simple object representing a terminal recording. Once the player fetches a file, it runs its contents through a parser, which turns it into a recording object used by the player's recording driver.</p> <p>Default parser used by the player is the asciicast parser, however another built-in or custom parser can be used by including <code>parser</code> option in the source argument of <code>AsciinemaPlayer.create</code>:</p> <pre><code>AsciinemaPlayer.create({ url: url, parser: parser }, containerElement);\n</code></pre> <p>Note</p> <p><code>parser</code> is a driver option. Driver options are options specific to each driver, and they must be passed in <code>create</code>'s first argument, together with a URL. <code>parser</code> is an option of the recording driver.</p> <p>Concept of drivers is not fully finalized yet and is subject to change. Feel free to check the source code of currently available drivers for what options are available. Be warned though: drivers other than the default recording one are experimental and may change in the future.</p>"},{"location":"manual/player/parsers/#data-model-of-a-recording","title":"Data model of a recording","text":"<p>asciinema player uses very simple internal representation of a recording.</p> <p>The object has the following fields:</p> <ul> <li><code>cols</code> - number of terminal columns (terminal width in chars),</li> <li><code>rows</code> - number of terminal rows (terminal height in lines),</li> <li><code>events</code> - iterable (e.g. an array, a generator) of events, where each item is   a 3 element array, containing event time (in seconds), event code and event   data.</li> </ul> <p>Example recording model:</p> <pre><code>{\n  cols: 80,\n  rows: 24,\n  events: [\n    [1.0, 'o', 'hello '],\n    [2.0, 'o', 'world!'],\n    [4.0, 'i', '\\u0004'],\n    [4.1, 'o', 'exit']\n  ]\n}\n</code></pre> <p>Similarly to asciicast event codes, the codes are:</p> <ul> <li><code>o</code> - output, i.e a write to a terminal</li> <li><code>i</code> - input, typically a key press</li> <li><code>m</code> - marker</li> </ul>"},{"location":"manual/player/parsers/#built-in-parsers","title":"Built-in parsers","text":"<p>A built-in parser can be used by setting the <code>parser</code> option to a string with parser name:</p> <pre><code>AsciinemaPlayer.create({ url: url, parser: 'parser-name' }, containerElement);\n</code></pre>"},{"location":"manual/player/parsers/#asciicast","title":"asciicast","text":"<p><code>asciicast</code> parser handles asciicast v3, asciicast v2 and asciicast v1 file formats produced by asciinema recorder.</p> <p>This parser is the default and does not have to be explicitly selected.</p>"},{"location":"manual/player/parsers/#typescript","title":"typescript","text":"<p><code>typescript</code> parser handles recordings in typescript format (not to be confused with Typescript language) produced by venerable script command.</p> <p>This parser supports both \"classic\" and \"advanced\" logging formats, including input streams.</p> <p>Usage:</p> <pre><code>AsciinemaPlayer.create({\n  url: ['/demo.timing', '/demo.data'],\n  parser: 'typescript'\n}, document.getElementById('demo'));\n</code></pre> <p>Note <code>url</code> above being an array of URLs pointing to typescript timing and data files.</p> <p>Usage for 3 file variant - timing file + output file + input file (created when recording with <code>script --log-in &lt;file&gt;</code>):</p> <pre><code>AsciinemaPlayer.create({\n  url: ['/demo.timing', '/demo.output', '/demo.input'],\n  parser: 'typescript'\n}, document.getElementById('demo'));\n</code></pre> <p>If the recording was created in a terminal configured with character encoding other than UTF-8 then <code>encoding</code> option should be included, specifying matching encoding to be used for decoding bytes into text:</p> <pre><code>AsciinemaPlayer.create({\n  url: ['/demo.timing', '/demo.data'],\n  parser: 'typescript',\n  encoding: 'iso-8859-2'\n}, document.getElementById('demo'));\n</code></pre> <p>See TextDecoder's encodings list for valid names.</p>"},{"location":"manual/player/parsers/#ttyrec","title":"ttyrec","text":"<p><code>ttyrec</code> parser handles recordings in ttyrec format produced by ttyrec, termrec or ipbt amongst others.</p> <p>This parser understands <code>\\e[8;Y;Xt</code> terminal size sequence injected into the first frame by termrec.</p> <p>Usage:</p> <pre><code>AsciinemaPlayer.create({\n  url: '/demo.ttyrec',\n  parser: 'ttyrec'\n}, document.getElementById('demo'));\n</code></pre> <p>If the recording was created in a terminal configured with character encoding other than UTF-8 then <code>encoding</code> option should be included, specifying matching encoding to be used for decoding bytes into text:</p> <pre><code>AsciinemaPlayer.create({\n  url: '/demo.ttyrec',\n  parser: 'ttyrec',\n  encoding: 'iso-8859-2'\n}, document.getElementById('demo'));\n</code></pre> <p>See TextDecoder's encodings list for valid names.</p>"},{"location":"manual/player/parsers/#custom-parsers","title":"Custom parsers","text":"<p>Custom format parser can be used by setting the <code>parser</code> option to a function:</p> <pre><code>AsciinemaPlayer.create({ url: url, parser: myParserFunction }, containerElement);\n</code></pre> <p>Custom parser function takes a Response object and returns an object conforming to the recording data model.</p> <p>Note</p> <p>While the following example parsers return <code>events</code> array, it may be any iterable or iterator that is finite, which in practice means you can return an array or a finite generator, amongst others.</p> <p>The following example illustrates implementation of a basic recording parser:</p> app.jsexample.txt <pre><code>function parse(response) {\n  return {\n    cols: 80,\n    rows: 6,\n    events: [[1.0, 'o', 'hello'], [2.0, 'o', ' world!']]\n  };\n};\n\nAsciinemaPlayer.create(\n  { url: '/example.txt', parser: parse },\n  document.getElementById('demo')\n);\n</code></pre> <pre><code>foo\nbar\nbaz\nqux\n</code></pre> <p>The above <code>parse</code> function returns a recording object, which makes the player print \"hello\" (at time = 1.0 sec), followed by \"world!\" a second later.  The parser is then passed to <code>create</code> together with a URL as source argument, which makes the player fetch a file (<code>example.txt</code>) and pass it through the parser function.</p> <p>The result:</p> <p>This parser is not quite there though. It ignores the content of <code>example.txt</code> file, always returning hardcoded output (\"hello\", followed by \"world!\"). Also, <code>cols</code> and <code>rows</code> are made up as well - if possible they should be extracted from the file and reflect the size of a terminal at the recording session time. The example illustrates what kind of data the player expects though.</p> <p>A more realistic example, where content of a file is actually used to construct the output, could look like this:</p> app.jsexample.log <pre><code>async function parseLogs(response) {\n  const text = await response.text();\n  const pattern = /^\\[([^\\]]+)\\] (.*)/;\n  let baseTime;\n\n  return {\n    cols: 80,\n    rows: 6,\n    events: text.split('\\n').map((line, i) =&gt; {\n      const [_, timestamp, message] = pattern.exec(line);\n      const time = (new Date(timestamp)).getTime() / 1000.0;\n      baseTime = baseTime ?? time - 1;\n      return [time - baseTime, 'o', message + '\\r\\n'];\n    })\n  };\n};\n\nAsciinemaPlayer.create(\n  { url: '/example.log', parser: parseLogs },\n  document.getElementById('demo')\n);\n</code></pre> <pre><code>[2023-11-13T12:00:00.000Z] \"GET /index.html HTTP/1.1\" 200\n[2023-11-13T12:00:01.000Z] \"POST /login HTTP/1.1\" 303\n[2023-11-13T12:00:01.250Z] \"GET /images/logo.png HTTP/1.1\" 200\n[2023-11-13T12:00:03.000Z] \"GET /css/style.css HTTP/1.1\" 304\n[2023-11-13T12:00:06.000Z] \"GET /js/app.js HTTP/1.1\" 200\n</code></pre> <p><code>parseLogs</code> function parses a log file into a recording which prints one log line every half a second.</p> <p>The result:</p> <p>Here's slightly more advanced parser, for Simon Jansen's Star Wars Asciimation:</p> <pre><code>const LINES_PER_FRAME = 14;\nconst FRAME_DELAY = 67;\nconst COLUMNS = 67;\nconst ROWS = LINES_PER_FRAME - 1;\n\nasync function parseAsciimation(response) {\n  const text = await response.text();\n  const lines = text.split('\\n');\n  const events = [];\n  let time = 0;\n  let prevFrameDuration = 0;\n\n  events.push([0, '\\x9b?25l']); // hide cursor\n\n  for (let i = 0; i + LINES_PER_FRAME - 1 &lt; lines.length; i += LINES_PER_FRAME) {\n    time += prevFrameDuration;\n    prevFrameDuration = parseInt(lines[i], 10) * FRAME_DELAY;\n    const frame = lines.slice(i + 1, i + LINES_PER_FRAME).join('\\r\\n');\n    let text = '\\x1b[H'; // move cursor home\n    text += '\\x1b[J'; // clear screen\n    text += frame; // print current frame's lines\n    events.push([time / 1000, 'o', text]);\n  }\n\n  return { cols: COLUMNS, rows: ROWS, events };\n}\n\nAsciinemaPlayer.create(\n  { url: '/starwars.txt', parser: parseAsciimation },\n  document.getElementById('demo')\n);\n</code></pre> <p>It parses Simon's Asciimation in its original format (please do not redistribute without giving Simon credit for it), where each animation frame is defined by 14 lines. First of every 14 lines defines duration a frame should be displayed for (multiplied by a speed constant, by default <code>67</code> ms), while lines 2-14 define frame content - text to display.</p> <p>The result:</p> <p>All example parsers above parse text (<code>response.text()</code>) however any binary format can be parsed easily by using binary data buffer with typed array object like Uint8Array:</p> <pre><code>async function parseMyBinaryFormat(response) {\n  const buffer = await response.arrayBuffer();\n  const array = new Uint8Array(buffer);\n  const events = [];\n  const firstByte = array[0];\n  const secondByte = array[1];\n  // parse the bytes and populate the events array\n\n  return { cols: 80, rows: 24, events };\n}\n</code></pre> <p>See ttyrec.js or typescript.js for examples of binary parsers.</p>"},{"location":"manual/player/quick-start/","title":"Quick start","text":"<p>This guide shows how to add asciinema player to your own website.</p> <p>It assumes you have obtained terminal session recording file by either recording a terminal with asciinema CLI (<code>asciinema rec demo.cast</code>), or downloading a <code>.cast</code> file from asciinema.org or a self-hosted asciinema server.</p> <p>For a broader overview of what's possible with asciinema check out the intro guide.</p>"},{"location":"manual/player/quick-start/#installation","title":"Installation","text":"<p>There are two ways of installing asciinema player on your website.</p> <p>You can just copy standalone (\"bundle\") version of player's JS and CSS files into your site assets directory and reference those in HTML via <code>&lt;script src=\"...\"&gt;</code> and <code>&lt;link rel=\"stylesheet\" href=\"...\"&gt;</code> tags.</p> <p>If you use a JavaScript bundler you can use asciinema-player npm package.</p>"},{"location":"manual/player/quick-start/#standalone-player-bundle","title":"Standalone player bundle","text":"<p>Download latest version of the player bundle from releases page. You only need <code>asciinema-player.min.js</code> and <code>asciinema-player.css</code> files.</p> <p>First, add <code>asciinema-player.min.js</code>, <code>asciinema-player.css</code> and the <code>.cast</code> file of your recording to your site's assets. The HTML snippet below assumes they're in the web server's root directory.</p> <p>Then add necessary includes to your HTML document and initialize the player inside an empty container <code>&lt;div&gt;</code> element:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  ...\n  &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/asciinema-player.css\" /&gt;\n  ...\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n  &lt;div id=\"demo\"&gt;&lt;/div&gt;\n  ...\n  &lt;script src=\"/asciinema-player.min.js\"&gt;&lt;/script&gt;\n  &lt;script&gt;\n    AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'));\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"manual/player/quick-start/#npm-package","title":"npm package","text":"<p>Add <code>asciinema-player</code> to your <code>devDependencies</code>:</p> <pre><code>npm install --save-dev asciinema-player@3.6.3\n</code></pre> <p>Add empty <code>&lt;div id=\"demo\"&gt;&lt;/div&gt;</code> element to your page to contain the player.</p> <p>Import <code>AsciinemaPlayer</code> from <code>asciinema-player</code> module and initialize the player inside an empty container <code>&lt;div&gt;</code> element:</p> <pre><code>import * as AsciinemaPlayer from 'asciinema-player';\nAsciinemaPlayer.create('/demo.cast', document.getElementById('demo'));\n</code></pre> <p>Finally, include player's CSS file in your site CSS bundle. It's at <code>dist/bundle/asciinema-player.css</code> in the npm package.</p>"},{"location":"manual/player/quick-start/#basic-usage","title":"Basic usage","text":"<p>In the code snippets above we initialized the player by calling <code>create</code> with 2 arguments. This function can in fact be called with 3 arguments:</p> <pre><code>AsciinemaPlayer.create(src, containerElement, opts);\n</code></pre> <p>The arguments are:</p> <ul> <li><code>src</code> - recording source, typically a recording URL,</li> <li><code>containerElement</code> - container DOM element, to mount the player in,</li> <li><code>opts</code> - configuration options (optional).</li> </ul> <p>In the most common case, <code>src</code> is a URL pointing to an asciicast file. You can pass it as a full URL, e.g. <code>\"https://example.com/demo.cast\"</code>, an absolute path, e.g. <code>\"/demo.cast\"</code>, or a relative path, e.g. <code>\"../casts/demo.cast\"</code>.</p> <p>Note</p> <p>A recording can be loaded from other sources, e.g. by inlining it in HTML or providing it through a function. See Loading a recording for available ways of getting a recording into the player.</p> <p>The third argument, <code>opts</code>, can be used to configure player's look and feel. For example, to enable looping and select Solarized Dark theme we pass <code>loop</code> and <code>theme</code> options like this:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  loop: true,\n  theme: 'dracula'\n});\n</code></pre> <p>See Options for a complete list of available options.</p> <p>Finally, if you'd like to control the player programmatically, you can use the methods of the player object, which is returned from the <code>create</code> function:</p> <pre><code>const player = AsciinemaPlayer.create(src, containerElement);\n\ndocument.getElementById('my-play-button').addEventListener('click', e =&gt; {\n  e.preventDefault();\n  player.play();\n});\n</code></pre> <p>See API for full overview of programmatic control.</p> <p>Before we conclude this guide here's an example of a player with a poster and a couple of markers, additionally controlled with external buttons.</p> <pre><code>const player = AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  poster: 'npt:1:17',\n  markers: [\n    [3, 'Intro'],\n    [5, 'Foo'],\n    [9, 'Bar'],\n    [15, 'Baz'],\n    [30, 'Qux'],\n  ]\n});\n\ndocument.getElementById('play-button').addEventListener('click', e =&gt; {\n  e.preventDefault();\n  player.play();\n});\n\ndocument.getElementById('prev-marker-button').addEventListener('click', e =&gt; {\n  e.preventDefault();\n  player.seek({ marker: 'prev' });\n});\n</code></pre> <p>Below is the result. Go ahead and use the big buttons below the player.</p> <p>Play Pause Prev marker Next marker</p> <p>That wraps up our quick start guide. There's way more to the player than we covered here though. Check out the rest of the documentation for further configuration and customization options.</p>"},{"location":"manual/player/shortcuts/","title":"Keyboard shortcuts","text":"<p>The following keyboard shortcuts are available when the player element has input focus:</p> <ul> <li>space - pause / resume</li> <li>\u2190 / \u2192 - rewind / fast-forward by 5 seconds</li> <li>Shift + \u2190 / \u2192 - rewind / fast-forward by 10%</li> <li>[ / ] - jump to the previous / next marker</li> <li>0, 1, 2 ... 9 - jump to 0%, 10%, 20% ... 90%</li> <li>, / . - step back / forward, a frame at a time (when paused)</li> <li>f - toggle fullscreen mode</li> <li>m - mute / unmute audio (when audio track present)</li> </ul> <p>Go ahead and try them out in the player below:</p>"},{"location":"manual/player/themes/","title":"Terminal themes","text":"<p>asciinema player can use one of the built-in terminal themes, as well as any custom terminal theme.</p> <p>To set a theme use the <code>theme</code> option. For example:</p> <pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  theme: 'dracula'\n});\n</code></pre>"},{"location":"manual/player/themes/#built-in-themes","title":"Built-in themes","text":"name added in version based on <code>asciinema</code> 2.0 <code>dracula</code> 3.6 draculatheme.com <code>gruvbox-dark</code> 3.10 github.com/morhetz/gruvbox <code>monokai</code> 2.0 github.com/chriskempson/base16 <code>nord</code> 3.3 github.com/arcticicestudio/nord <code>solarized-dark</code> 2.0 ethanschoonover.com/solarized/ <code>solarized-light</code> 2.0 ethanschoonover.com/solarized/ <code>tango</code> 2.0 en.wikipedia.org/wiki/Tango_Desktop_Project"},{"location":"manual/player/themes/#custom-themes","title":"Custom themes","text":"<p>To use a custom theme, first define a CSS class named <code>asciinema-player-theme-&lt;name&gt;</code>, e.g. <code>asciinema-player-theme-foobar</code>. Then, set the <code>theme</code> option to the name of the theme, e.g.  <code>theme: 'foobar'</code>.</p> <p>asciinema player themes use custom CSS properties, aka CSS variables, for specifying the colors.</p> <p>The palette may include either 8 or 16 colors. When 8 colors are defined the player automatically maps colors 8-15 to colors 0-7. In other words, if the high colors (8-15) should be the same as low colors (0-7) you can define just the low colors.</p> <p>The below definition of a built-in Dracula theme demonstrates how a theme is constructed:</p> dracula.css<pre><code>.asciinema-player-theme-dracula {\n  /* Foreground (default text) color */\n  --term-color-foreground: #f8f8f2;\n\n  /* Background color */\n  --term-color-background: #282a36;\n\n  /* Palette of 16 standard ANSI colors */\n  --term-color-0: #21222c;\n  --term-color-1: #ff5555;\n  --term-color-2: #50fa7b;\n  --term-color-3: #f1fa8c;\n  --term-color-4: #bd93f9;\n  --term-color-5: #ff79c6;\n  --term-color-6: #8be9fd;\n  --term-color-7: #f8f8f2;\n  --term-color-8: #6272a4;\n  --term-color-9: #ff6e6e;\n  --term-color-10: #69ff94;\n  --term-color-11: #ffffa5;\n  --term-color-12: #d6acff;\n  --term-color-13: #ff92df;\n  --term-color-14: #a4ffff;\n  --term-color-15: #ffffff;\n}\n</code></pre> <p>The built-in Nord theme is an example of a theme with 8-color palette:</p> nord.css<pre><code>.asciinema-player-theme-nord {\n  --term-color-foreground: #eceff4;\n  --term-color-background: #2e3440;\n\n  --term-color-0: #3b4252;\n  --term-color-1: #bf616a;\n  --term-color-2: #a3be8c;\n  --term-color-3: #ebcb8b;\n  --term-color-4: #81a1c1;\n  --term-color-5: #b48ead;\n  --term-color-6: #88c0d0;\n  --term-color-7: #eceff4;\n}\n</code></pre>"},{"location":"manual/player/themes/#automatic-dark-mode","title":"Automatic dark mode","text":"<p>Since a theme is defined with CSS, it can utilize media queries such as prefers-color-scheme to use a different set of colors when dark mode is reported by the operating system/browser.</p> <p>Below is an example of the <code>solarized-auto</code> theme, which defaults to colors from the <code>solarized-light</code> palette and switches to colors from the <code>solarized-dark</code> palette when dark mode is active in the operating system:</p> solarized-auto.css<pre><code>.asciinema-player-theme-solarized-auto {\n  --term-color-foreground: #657b83;\n  --term-color-background: #fdf6e3;\n\n  --term-color-0: #073642;\n  --term-color-1: #dc322f;\n  --term-color-2: #859900;\n  --term-color-3: #b58900;\n  --term-color-4: #268bd2;\n  --term-color-5: #d33682;\n  --term-color-6: #2aa198;\n  --term-color-7: #eee8d5;\n  --term-color-8: #002b36;\n  --term-color-9: #cb4b16;\n  --term-color-10: #586e75;\n  --term-color-11: #657c83;\n  --term-color-12: #839496;\n  --term-color-13: #6c71c4;\n  --term-color-14: #93a1a1;\n  --term-color-15: #fdf6e3;\n}\n\n@media (prefers-color-scheme: dark) {\n  .asciinema-player-theme-solarized-auto {\n    --term-color-foreground: #839496;\n    --term-color-background: #002b36;\n\n    --term-color-0: #073642;\n    --term-color-1: #dc322f;\n    --term-color-2: #859900;\n    --term-color-3: #b58900;\n    --term-color-4: #268bd2;\n    --term-color-5: #d33682;\n    --term-color-6: #2aa198;\n    --term-color-7: #eee8d5;\n    --term-color-8: #002b36;\n    --term-color-9: #cb4b16;\n    --term-color-10: #586e75;\n    --term-color-11: #657b83;\n    --term-color-12: #839496;\n    --term-color-13: #6c71c4;\n    --term-color-14: #93a1a1;\n    --term-color-15: #fdf6e3;\n  }\n}\n</code></pre> <p>Use it by setting <code>theme: 'solarized-auto'</code> when initializing the player:</p> app.js<pre><code>AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n  theme: 'solarized-auto'\n});\n</code></pre>"},{"location":"manual/player/upgrading/","title":"Upgrading","text":"<p>asciinema player follows semantic versioning model therefore it should always be safe to upgrade to a higher minor or patch version, e.g. from v3.0.0 to v3.6.3, without the risk of breaking functionality.</p> <p>Upgrading to a higher major version, e.g. from v2.x to v3.x, may involve changes to player configuration and/or usage. This page includes upgrade guides for such cases.</p>"},{"location":"manual/player/upgrading/#upgrading-from-v2-to-v3","title":"Upgrading from v2 to v3","text":"<p>v2.x used, now deprecated, <code>document.registerElement(...)</code> API for registering <code>&lt;asciinema-player&gt;</code> custom HTML element. This way of initializing the player has been removed in v3.x, replaced with standard JavaScript API.</p> <p>Instead of:</p> 2.x<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  ...\n  &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/asciinema-player.css\" /&gt;\n  ...\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n  &lt;asciinema-player src=\"/demo.cast\" speed=\"2\" loop&gt;&lt;/asciinema-player&gt;\n  ...\n  &lt;script src=\"/asciinema-player.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Use:</p> 3.x<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  ...\n  &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/asciinema-player.css\" /&gt;\n  ...\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n  &lt;div id=\"demo\"&gt;&lt;/div&gt;\n  ...\n  &lt;script src=\"/asciinema-player.min.js\"&gt;&lt;/script&gt;\n  &lt;script&gt;\n    AsciinemaPlayer.create('/demo.cast', document.getElementById('demo'), {\n      speed: 2,\n      loop: true\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Info</p> <p>There's also asciinema-player npm package, which can be used instead of the standalone bundle. Check the quick start guide for details.</p> <p><code>src</code> attribute becomes the first argument to <code>AsciinemaPlayer.create()</code>. The second argument specifies the container element to mount the player under. All other option attributes are now passed in options objects as the third argument.</p> <p>The following table shows how 2.x attributes map to new 3.x options:</p> 2.x attribute 3.x option example notes <code>cols</code> <code>cols</code> <code>{ cols: 80 }</code> <code>rows</code> <code>rows</code> <code>{ rows: 24 }</code> <code>autoplay</code> <code>autoPlay</code> <code>{ autoPlay: true }</code> <code>preload</code> <code>preload</code> <code>{ preload: true }</code> <code>loop</code> <code>loop</code> <code>{ loop: true }</code> or <code>{ loop: 3 }</code> <code>start-at</code> <code>startAt</code> <code>{ startAt: 33 }</code> <code>speed</code> <code>speed</code> <code>{ speed: 2 }</code> <code>idle-time-limit</code> <code>idleTimeLimit</code> <code>{ idleTimeLimit: 2 }</code> <code>poster</code> <code>poster</code> <code>{ poster: \"npt:2:34\" }</code> <code>font-size</code> <code>terminalFontSize</code> <code>{ terminalFontSize: \"20px\", fit: false }</code> requires <code>fit: false</code> <code>theme</code> <code>theme</code> <code>{ theme: \"dracula\" }</code> <code>title</code> - - removed <code>author</code> - - removed <code>author-url</code> - - removed <code>author-img-url</code> - - removed"},{"location":"manual/server/","title":"asciinema server","text":"<p>asciinema server is a server-side component of the asciinema ecosystem.</p> <p>It implements a hosting platform for terminal session recordings and live streaming. It offers a familiar web interface for viewing, browsing, sharing and managing recordings and streams. This includes HTTP API, which is used by the asciinema CLI.</p> <p>The server is built with Elixir language and Phoenix framework. It embeds asciinema's virtual terminal, avt, which is utilized by tasks such as preview generation, recording analysis and live stream state bookkeeping.</p> <p>asciinema.org is a public asciinema server instance managed by the asciinema project team, providing free hosting for terminal recordings and streams, available to everyone. Check asciinema.org/about to learn more about this instance.</p> <p>You can easily self-host asciinema server and use the asciinema CLI with your own instance. If you're not comfortable with hosting your data at asciinema.org, if your company policy prevents you from doing so, or if you simply prefer self-hosting everything, then asciinema has you covered.</p> <p>Notable features:</p> <ul> <li>hosting of terminal session recordings in asciicast   format,</li> <li>live streaming of terminal sessions,</li> <li>perfectly integrated asciinema player for best viewing   experience,</li> <li>full-text search using recording titles, descriptions, and full terminal   session content,</li> <li>easy sharing of recordings via secret links,</li> <li>easy embedding of the player, or linking via preview images   (SVG),</li> <li>privacy friendly - no tracking, no ads,</li> <li>visibility control for recordings: private, unlisted, public,</li> <li>editable recording metadata like title or long description (Markdown),</li> <li>configurable terminal themes and font families (including Nerd Font   variants),</li> <li>download of plain text transcripts (<code>.txt</code>) of recordings.</li> </ul> <p>asciinema server is free and open-source software (FOSS). Source code and license available at github.com/asciinema/asciinema-server.</p>"},{"location":"manual/server/api/","title":"API","text":"<p>asciinema server provides an HTTP API for interacting with the server programmatically.</p> <p>The latest version of the API is v1, and is available at <code>/api/v1/</code>.</p>"},{"location":"manual/server/api/#authentication","title":"Authentication","text":"<p>All API endpoints require authentication using HTTP Basic Authentication with your CLI install ID. The install ID uniquely identifies your CLI, and is generated in <code>~/.config/asciinema/install-id</code> when running <code>asciinema auth</code> for the first time on a given system.</p> <p>Most endpoints require the CLI to be registered with the server by completing the steps displayed by the <code>asciinema auth</code> command.</p> <p>The exception is the upload endpoint (<code>POST /api/v1/recordings</code>). Unless the server uses <code>UPLOAD_AUTH_REQUIRED=1</code> configuration option, this endpoint allows requests from unregistered CLIs. In such cases, created recordings are temporary and subject to automatic removal, unless the <code>asciinema auth</code> flow is completed on the same system within server-configured grace period. See <code>asciinema auth --help</code> for more details.</p> <p>Note</p> <p>The above is rather CLI-centric, and that's because the API evolved to support the needs of the asciinema CLI over the years. In the future, the server will provide other authentication methods, such as pre-authorized access tokens or OAuth2, to make the API easier to use in non-interactive contexts.</p>"},{"location":"manual/server/api/#authentication-header","title":"Authentication header","text":"<p>Use the install ID as the password field in Basic Authentication. The username field can be an empty string.</p> <pre><code>Authorization: Basic &lt;base64(:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)&gt;\n</code></pre> <p>For brevity, this header is omitted in request examples of endpoint descriptions.</p>"},{"location":"manual/server/api/#example-request-using-curl","title":"Example request using cURL","text":"<pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X PATCH \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\":\"Updated Title\",\"visibility\":\"public\"}' \\\n  https://asciinema.org/api/v1/recordings/123\n</code></pre>"},{"location":"manual/server/api/#request-and-response-format","title":"Request and response format","text":"<p>Most API endpoints expect request bodies to be JSON encoded (<code>Content-Type: application/json</code>). Exceptions to this are noted in endpoint descriptions.</p> <p>The only supported response format is also JSON, and requests must include either <code>Accept: application/json</code> or <code>Accept: */*</code> header.</p> <p>Successful responses (2xx status) return resource attributes directly (no envelopes). Error responses (4xx status) typically return error details in the <code>error</code> field.</p>"},{"location":"manual/server/api/#errors","title":"Errors","text":"<p>Common HTTP status codes used by the API for error cases:</p> Status Code Description 401 Unauthorized - Missing or invalid auth header 403 Forbidden - Access denied (e.g., streaming disabled) 404 Not Found - Resource not found 422 Unprocessable Entity - Validation errors"},{"location":"manual/server/api/#resources","title":"Resources","text":""},{"location":"manual/server/api/#recordings","title":"Recordings","text":"<p><code>Recording</code> resources represent terminal session recordings.</p> <p>Recording attributes:</p> Attribute Type Description Modifiable <code>id</code> Integer Recording ID No <code>url</code> String (URL) Web URL No <code>file_url</code> String (URL) asciicast file URL No <code>audio_url</code> String (URL) Audio file URL, e.g., mp3 Yes <code>title</code> String A title Yes <code>description</code> String (Markdown) A description Yes <code>visibility</code> Enum: <code>public</code>, <code>unlisted</code>, <code>private</code> Visibility Yes <p>Note</p> <p>The <code>:id</code> path parameter in recording endpoints accepts either a recording's numerical ID (<code>id</code> in the table above) or a URL token.</p> <p>A URL token is a unique token assigned to unlisted and private recordings, and used in place of the numerical ID in web URLs of those recordings. For example, for a recording with the web URL <code>https://asciinema.org/a/iUagQ1fL8tBvSZYiQGfPFCWIP</code> the URL token is <code>iUagQ1fL8tBvSZYiQGfPFCWIP</code>.</p>"},{"location":"manual/server/api/#create","title":"Create","text":"<pre><code>POST /api/v1/recordings\n</code></pre> <p>Create a new recording from an asciicast file.</p> <p>Note</p> <p>In contrast to other endpoints, this one expects the request body to be encoded as <code>multipart/form-data</code>.</p> <p>The only required attribute is <code>file</code>.</p> <p>Request:</p> <pre><code>POST /api/v1/recordings HTTP/1.1\nContent-Type: multipart/form-data; boundary=----FormBoundary123\nAccept: application/json\n\n------FormBoundary123\nContent-Disposition: form-data; name=\"file\"; filename=\"demo.cast\"\nContent-Type: application/octet-stream\n\n[recording file content]\n------FormBoundary123--\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\nLocation: https://asciinema.org/a/eST2byL7IZkbGOBaMqE4Jhrqp\n\n{\n  \"id\": 123,\n  \"url\": \"https://asciinema.org/a/eST2byL7IZkbGOBaMqE4Jhrqp\",\n  \"file_url\": \"https://asciinema.org/a/eST2byL7IZkbGOBaMqE4Jhrqp.cast\",\n  \"audio_url\": null,\n  \"title\": null,\n  \"description\": null,\n  \"visibility\": \"unlisted\"\n}\n</code></pre> <p>cURL example:</p> <pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X POST \\\n  -u \":${INSTALL_ID}\" \\\n  -F \"file=@demo.cast\" \\\n  https://asciinema.org/api/v1/recordings\n</code></pre>"},{"location":"manual/server/api/#update","title":"Update","text":"<pre><code>PATCH /api/v1/recordings/:id\n</code></pre> <p>Update metadata and settings for an existing recording.</p> <p>Request:</p> <pre><code>PATCH /api/v1/recordings/123 HTTP/1.1\nContent-Type: application/json\nAccept: application/json\n\n{\n  \"title\": \"Updated Recording Title\",\n  \"description\": \"Updated description\",\n  \"visibility\": \"public\"\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": 123,\n  \"url\": \"https://asciinema.org/a/eST2byL7IZkbGOBaMqE4Jhrqp\",\n  \"file_url\": \"https://asciinema.org/a/eST2byL7IZkbGOBaMqE4Jhrqp.cast\",\n  \"audio_url\": null,\n  \"title\": \"Updated Recording Title\",\n  \"description\": \"Updated description\",\n  \"visibility\": \"public\"\n}\n</code></pre> <p>cURL example:</p> <pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X PATCH \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\":\"Updated Title\",\"visibility\":\"public\"}' \\\n  https://asciinema.org/api/v1/recordings/123\n</code></pre>"},{"location":"manual/server/api/#delete","title":"Delete","text":"<pre><code>DELETE /api/v1/recordings/:id\n</code></pre> <p>Permanently delete a recording.</p> <p>Request:</p> <pre><code>DELETE /api/v1/recordings/123 HTTP/1.1\nAccept: application/json\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\n</code></pre> <p>cURL example:</p> <pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X DELETE -u \":${INSTALL_ID}\" https://asciinema.org/api/v1/recordings/123\n</code></pre>"},{"location":"manual/server/api/#streams","title":"Streams","text":"<p><code>Stream</code> resources represent endpoint configurations for live terminal session broadcasts.</p> <p>Stream attributes:</p> Attribute Type Description Modifiable <code>id</code> Integer Stream ID No <code>url</code> String (URL) Web URL No <code>ws_producer_url</code> String (URL) Producer WebSocket endpoint No <code>audio_url</code> String (URL) Audio URL, e.g., Icecast stream endpoint Yes <code>title</code> String A title Yes <code>description</code> String (Markdown) A description Yes <code>visibility</code> Enum: <code>public</code>, <code>unlisted</code>, <code>private</code> Visibility Yes <p>Note</p> <p>The <code>:id</code> path parameter in stream endpoints accepts either a stream's numerical ID (<code>id</code> in the table above) or a URL token.</p> <p>A URL token is a unique token assigned to unlisted and private streams, and used in place of the numerical ID in web URLs of those streams. For example, for a stream with the web URL <code>https://asciinema.org/s/iUagQ1fL8tBvSZYi</code> the URL token is <code>iUagQ1fL8tBvSZYi</code>.</p>"},{"location":"manual/server/api/#list","title":"List","text":"<pre><code>GET /api/v1/user/streams\n</code></pre> <p>List own streams.</p> <p>This endpoint performs pagination and returns up to 10 streams per page by default. Use <code>limit</code> query param to use higher limit (up to 100).</p> <p>URL for the next page of results is returned in the standard Link response header, with <code>rel</code> set to <code>next</code>.</p> <p>You can filter the streams by a prefix of a URL token (<code>En81VpLKVaA7U2NR</code> for the first stream in the response below) using <code>prefix=...</code> query param. For example: <code>prefix=En81</code>.</p> <p>Request:</p> <pre><code>GET /api/v1/user/streams?limit=3 HTTP/1.1\nContent-Type: application/json\nAccept: application/json\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nLink: &lt;https://asciinema.org/api/v1/user/streams?cursor=eyJpZCI6NTM5MDIsInByZWZpeCI6bnVsbH0%3D&amp;limit=10&gt;; rel=\"next\"\n\n[\n  {\n    \"id\": 1,\n    \"url\": \"https://asciinema.org/s/En81VpLKVaA7U2NR\",\n    \"ws_producer_url\": \"wss://asciinema.org/ws/S/9pJm0ppDDtuyBHWQ\",\n    \"audio_url\": null,\n    \"live\": true,\n    \"title\": \"Stream 1\",\n    \"description\": null,\n    \"visibility\": \"unlisted\"\n  },\n  {\n    \"id\": 2,\n    \"url\": \"https://asciinema.org/s/VaA7U2NREn81VpLK\",\n    \"ws_producer_url\": \"wss://asciinema.org/ws/S/m0ppDDtuyBHWQ9pJ\",\n    \"audio_url\": null,\n    \"live\": false,\n    \"title\": \"Stream 2\",\n    \"description\": null,\n    \"visibility\": \"public\"\n  },\n  {\n    \"id\": 3,\n    \"url\": \"https://asciinema.org/s/pLKVaA7U2NREn81V\",\n    \"ws_producer_url\": \"wss://asciinema.org/ws/S/DDtuyBHWQ9pJm0pp\",\n    \"audio_url\": null,\n    \"live\": true,\n    \"title\": \"Stream 3\",\n    \"description\": null,\n    \"visibility\": \"unlisted\"\n  }\n]\n</code></pre> <p>cURL example:</p> <pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X GET \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  https://asciinema.org/api/v1/user/streams?limit=3\n</code></pre>"},{"location":"manual/server/api/#create_1","title":"Create","text":"<pre><code>POST /api/v1/streams\n</code></pre> <p>Create a new live stream endpoint.</p> <p>This doesn't start the broadcast automatically. A live stream can be started by connecting to the producer WebSocket endpoint (<code>ws_producer_url</code>) and feeding session events into it. See Live streaming for details.</p> <p>This endpoint doesn't require any attributes, but some may be provided.</p> <p>Request:</p> <pre><code>POST /api/v1/streams HTTP/1.1\nContent-Type: application/json\nAccept: application/json\n\n{\n  \"title\": \"Stream Title\",\n  \"visibility\": \"public\",\n  \"live\": true\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\nLocation: https://asciinema.org/s/En81VpLKVaA7U2NR\n\n{\n  \"id\": 123,\n  \"url\": \"https://asciinema.org/s/En81VpLKVaA7U2NR\",\n  \"ws_producer_url\": \"wss://asciinema.org/ws/S/9pJm0ppDDtuyBHWQ\",\n  \"audio_url\": null,\n  \"live\": true,\n  \"title\": \"Stream Title\",\n  \"description\": null,\n  \"visibility\": \"public\"\n}\n</code></pre> <p>cURL example:</p> <pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X POST \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{}' \\\n  https://asciinema.org/api/v1/streams\n</code></pre>"},{"location":"manual/server/api/#update_1","title":"Update","text":"<pre><code>PATCH /api/v1/streams/:id\n</code></pre> <p>Update metadata and settings for an existing stream.</p> <p>Request:</p> <pre><code>PATCH /api/v1/streams/123 HTTP/1.1\nContent-Type: application/json\nAccept: application/json\n\n{\n  \"title\": \"Updated Stream Title\",\n  \"description\": \"Updated stream description\",\n  \"live\": true\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": 123,\n  \"url\": \"https://asciinema.org/s/En81VpLKVaA7U2NR\",\n  \"ws_producer_url\": \"wss://asciinema.org/ws/S/9pJm0ppDDtuyBHWQ\",\n  \"audio_url\": null,\n  \"live\": true,\n  \"title\": \"Updated Stream Title\",\n  \"description\": \"Updated stream description\",\n  \"visibility\": \"unlisted\"\n}\n</code></pre> <p>cURL example:</p> <pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X PATCH \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\":\"Updated Stream Title\",\"visibility\":\"public\"}' \\\n  https://asciinema.org/api/v1/streams/123\n</code></pre>"},{"location":"manual/server/api/#delete_1","title":"Delete","text":"<pre><code>DELETE /api/v1/streams/:id\n</code></pre> <p>Permanently delete a stream.</p> <p>Request:</p> <pre><code>DELETE /api/v1/streams/123 HTTP/1.1\nAccept: application/json\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 204 No Content\n</code></pre> <p>cURL example:</p> <pre><code>INSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\ncurl -X DELETE -u \":${INSTALL_ID}\" https://asciinema.org/api/v1/streams/123\n</code></pre>"},{"location":"manual/server/embedding/","title":"Embedding","text":"<p>Recordings hosted on an asciinema server instance, such as asciinema.org, can be easily embedded on any website either as an inline player or as a link containing a preview image of the recording.</p> <p>This allows you to enrich a blog post or project documentation with minimal effort.</p> <p>When embedding with the methods presented below, all the assets are served from asciinema.org. This server has been operational since 2012 and hopefully isn't going anywhere (you can help by donating). However, if you prefer not to depend on a third party, consider including the standalone player on your website, or self-hosting the server.</p>"},{"location":"manual/server/embedding/#inline-player","title":"Inline player","text":"<p>You can embed a player for your recording in a page by inserting a recording-specific <code>&lt;script&gt;</code> tag, which serves the player and the recording from asciinema.org. Check the alternative Preview image link option if a website doesn't permit inserting <code>&lt;script&gt;</code> tags.</p> <p>To get the inline player snippet for a recording click on the \"Share\" button on the recording page. The snippet looks like this:</p> <pre><code>&lt;script src=\"https://asciinema.org/a/bJMOlPe5F4mFLY0Rl6fiJSOp3.js\" id=\"asciicast-bJMOlPe5F4mFLY0Rl6fiJSOp3\" async&gt;&lt;/script&gt;\n</code></pre> <p>The script adds the player to a page at the location of the script itself, allowing precise placement by simply copy-pasting the snippet.</p> <p>The script injects an <code>&lt;iframe&gt;</code> element into the page, into which the asciinema player is loaded. The frame is automatically resized, using the full width of the containing element and adjusting its height to maintain the proportions of the recorded terminal.</p> <p>Here's how it looks:</p> <p>The look and feel of the inline player defaults to the settings used by the author on the recording settings page. Many of those can be overridden by using custom data attributes with the <code>&lt;script&gt;</code> tag.</p> <p>The following embed snippet makes the player start playback from the 25-second mark (<code>data-start-at=\"25\"</code>), play at 2x speed (<code>data-speed=\"2\"</code>), and use the Solarized Dark terminal theme (<code>data-theme=\"solarized-dark\"</code>):</p> <pre><code>&lt;script src=\"https://asciinema.org/a/bJMOlPe5F4mFLY0Rl6fiJSOp3.js\" id=\"asciicast-bJMOlPe5F4mFLY0Rl6fiJSOp3\" async data-start-at=\"25\" data-speed=\"2\" data-theme=\"solarized-dark\"&gt;&lt;/script&gt;\n</code></pre> <p>Here's how it looks with those additional options applied:</p> <p>The list of available options, along with their descriptions, is provided below. Add them as <code>data-&lt;option-name&gt;=\"value\"</code> attributes on the embed <code>&lt;script&gt;</code> tag, as shown in the example above.</p>"},{"location":"manual/server/embedding/#start-at","title":"start-at","text":"<p>Use <code>start-at</code> to start start the playback at a given time.</p> <p>Supported formats:</p> <ul> <li><code>123</code> (number of seconds)</li> <li><code>2:03</code> (mm:ss)</li> <li><code>1:02:03</code> (hh:mm:ss)</li> </ul> <p>Defaults to <code>0</code>.</p> <p>Note</p> <p>When <code>start-at</code> is specified then <code>autoplay=1</code> is implied. To prevent the player from starting automatically when <code>start-at</code> parameter is set you have to additionally use <code>autoplay=0</code>.</p>"},{"location":"manual/server/embedding/#autoplay","title":"autoplay","text":"<p>Use <code>autoplay</code> to control whether the playback should start automatically upon a page load.</p> <p>Accepted values:</p> <ul> <li>no value, i.e. <code>&lt;script ... data-autoplay ...&gt;</code> - start the playback automatically</li> <li><code>1</code> / <code>true</code> - start the playback automatically</li> <li><code>0</code> / <code>false</code> - don't start the playback automatically (default)</li> </ul>"},{"location":"manual/server/embedding/#loop","title":"loop","text":"<p>Use <code>loop</code> to enable looped playback.</p> <p>Accepted values:</p> <ul> <li>no value, i.e. <code>&lt;script ... data-loop ...&gt;</code> - enable looped playback</li> <li><code>1</code> / <code>true</code> - enable looped playback</li> <li><code>0</code> / <code>false</code> - disable looped playback (default)</li> </ul>"},{"location":"manual/server/embedding/#speed","title":"speed","text":"<p>Use <code>speed</code> to alter the playback speed.</p> <p>Accepts an integer or a float.</p> <p>For example:</p> <ul> <li><code>2</code> (2x faster)</li> <li><code>0.5</code> (2x slower)</li> </ul> <p>Defaults to <code>1</code> - original recording speed.</p>"},{"location":"manual/server/embedding/#idle-time-limit","title":"idle-time-limit","text":"<p>Use <code>idle-time-limit</code> to optimize away idle moments in a recording.</p> <p>Accepts an integer or a float, representing a maximum idle time between animation frames.</p> <p>For example, when set to <code>2</code> any inactivity longer than 2 seconds will be \"compressed\" to 2 seconds.</p> <p>Defaults to either:</p> <ul> <li>\"Idle time limit\" setting from the recording settings page,</li> <li><code>idle_time_limit</code> from asciicast header (saved   when <code>--idle-time-limit &lt;sec&gt;</code> is used with <code>asciinema rec</code>),</li> <li>no limit if none of the above is present.</li> </ul>"},{"location":"manual/server/embedding/#theme","title":"theme","text":"<p>Use <code>theme</code> to override a theme used for the player's terminal.</p> <p>The available themes are:</p> <ul> <li>asciinema</li> <li>dracula</li> <li>monokai</li> <li>nord</li> <li>solarized-dark</li> <li>solarized-light</li> <li>tango</li> </ul> <p>Defaults to either:</p> <ul> <li>\"Terminal theme\" from the recording settings page,</li> <li>\"asciinema\" theme.</li> </ul>"},{"location":"manual/server/embedding/#poster","title":"poster","text":"<p>Use <code>poster</code> to specify an alternative poster (preview frame) to display in player's terminal until the playback is started.</p> <p>Currently only NPT (\"Normal Play Time\") notation is supported.</p> <p>For example, <code>poster=npt:1:23</code> will display a preview frame at 1 min 23 sec.</p> <p>Defaults to either:</p> <ul> <li>\"Thumbnail frame\" from the recording settings page,</li> <li>50% of the recording duration.</li> </ul>"},{"location":"manual/server/embedding/#cols","title":"cols","text":"<p>Use <code>cols</code> to override player's terminal width, i.e number of columns.</p> <p>Defaults to either:</p> <ul> <li>\"Terminal columns\" from the recording settings page,</li> <li>columns saved in the recording file.</li> </ul> <p>Warning</p> <p>Setting <code>cols</code> to a value smaller than the one from the original recording may break the rendering of sessions containing \"full screen\" programs like <code>vim</code>, <code>htop</code> or <code>less</code>. It's usually safe to override <code>cols</code> for recordings of basic command execution in a shell.</p>"},{"location":"manual/server/embedding/#rows","title":"rows","text":"<p>Use <code>rows</code> to override player's terminal height, i.e number of rows.</p> <p>Defaults to either:</p> <ul> <li>\"Terminal rows\" from the recording settings page,</li> <li>rows saved in the recording file.</li> </ul> <p>Warning</p> <p>The same caveat applies as with the <code>cols</code> option above.</p>"},{"location":"manual/server/embedding/#preload","title":"preload","text":"<p>Use <code>preload</code> to control whether the player should start fetching the recording immediately upon a page load, before a viewer starts the playback.</p> <ul> <li><code>0</code> / <code>false</code> - don't preload the recording (default)</li> <li><code>1</code> / <code>true</code> - preload the recording</li> </ul> <p>Note</p> <p>When <code>poster</code> is specified then <code>preload=1</code> is implied. That's because the player needs to load the recording in order to generate a preview frame.</p>"},{"location":"manual/server/embedding/#preview-image-link","title":"Preview image link","text":"<p>Embedding as an image link is useful in places where <code>&lt;script&gt;</code> tags are not allowed, such as in a project's README file rendered by Github.</p> <p>To get the preview link snippet for a recording click on the \"Share\" button on the recording page. The snippet looks like this:</p> HTMLMarkdown <pre><code>&lt;a href=\"https://asciinema.org/a/bJMOlPe5F4mFLY0Rl6fiJSOp3\" target=\"_blank\"&gt;&lt;img src=\"https://asciinema.org/a/bJMOlPe5F4mFLY0Rl6fiJSOp3.svg\" /&gt;&lt;/a&gt;\n</code></pre> <pre><code>[![asciicast](https://asciinema.org/a/bJMOlPe5F4mFLY0Rl6fiJSOp3.svg)](https://asciinema.org/a/bJMOlPe5F4mFLY0Rl6fiJSOp3)\n</code></pre> <p>Below is the result. It resembles a player with a large play button, but it simply links to a recording. The preview image is an SVG file, which ensures it looks great in all contexts and on all screen sizes.</p> <p></p>"},{"location":"manual/server/embedding/#oembed","title":"oEmbed","text":"<p>asciinema server provides oEmbed endpoint at <code>/oembed</code>, which uses standard query params: <code>url</code> (required), <code>maxwidth</code>, <code>maxheight</code> and <code>format</code> (either <code>json</code> or <code>xml</code>, defaults to <code>json</code>).</p>"},{"location":"manual/server/sharing/","title":"Sharing","text":"<p>Every asciinema server instance, such as asciinema.org, allows easy sharing of recordings via unique, unguessable recording links.</p>"},{"location":"manual/server/sharing/#getting-a-link","title":"Getting a link","text":"<p>You can get a share link for a specific recording by clicking on the \"Share\" button on the recording page. Anyone you give a link to can view the recording.</p>"},{"location":"manual/server/sharing/#customizing-a-link","title":"Customizing a link","text":"<p>When a recording link is opened, the look and feel of the player defaults to the settings used by the author on the recording settings page. Many of those can be overridden on a per-link basis by appending additional query parameters (<code>?...</code>) to the link.</p> <p>For example, below link makes the player start at 25 second mark (<code>t=25</code>), play at 2x speed (<code>speed=2</code>), and use Nord terminal theme (<code>theme=nord</code>):</p> <pre><code>https://asciinema.org/a/P1TkxghJg83gKt4rFV8wCKH4f?t=25&amp;speed=2&amp;theme=nord\n</code></pre> <p>The list of available parameters, along with their descriptions, is provided below:</p>"},{"location":"manual/server/sharing/#startat","title":"startAt","text":"<p>Use <code>startAt</code>, or shorter <code>t</code>, to start start the playback at a given time.</p> <p>Supported formats:</p> <ul> <li><code>123</code> (number of seconds)</li> <li><code>2:03</code> (mm:ss)</li> <li><code>1:02:03</code> (hh:mm:ss)</li> </ul> <p>Defaults to <code>0</code>.</p> <p>Note</p> <p>When <code>startAt</code> is specified then <code>autoplay=1</code> is implied. To prevent the player from starting automatically when <code>startAt</code> parameter is set you have to additionally use <code>autoplay=0</code>.</p>"},{"location":"manual/server/sharing/#autoplay","title":"autoplay","text":"<p>Use <code>autoplay</code> to control whether the playback should start automatically upon a page load.</p> <p>Accepted values:</p> <ul> <li><code>0</code> / <code>false</code> - don't start the playback automatically (default)</li> <li><code>1</code> / <code>true</code> - start the playback automatically</li> </ul>"},{"location":"manual/server/sharing/#loop","title":"loop","text":"<p>Use <code>loop</code> to enable looped playback.</p> <p>Accepted values:</p> <ul> <li><code>0</code> / <code>false</code> - disable looped playback (default)</li> <li><code>1</code> / <code>true</code> - enable looped playback</li> </ul>"},{"location":"manual/server/sharing/#speed","title":"speed","text":"<p>Use <code>speed</code> to alter the playback speed.</p> <p>Accepts an integer or a float.</p> <p>For example:</p> <ul> <li><code>2</code> (2x faster)</li> <li><code>0.5</code> (2x slower)</li> </ul> <p>Defaults to <code>1</code> - original recording speed.</p>"},{"location":"manual/server/sharing/#idletimelimit","title":"idleTimeLimit","text":"<p>Use <code>idleTimeLimit</code> to optimize away idle moments in a recording.</p> <p>Accepts an integer or a float, representing a maximum idle time between animation frames.</p> <p>For example, when set to <code>2</code> any inactivity longer than 2 seconds will be \"compressed\" to 2 seconds.</p> <p>Defaults to either:</p> <ul> <li>\"Idle time limit\" setting from the recording settings page,</li> <li><code>idle_time_limit</code> from asciicast header (saved   when <code>--idle-time-limit &lt;sec&gt;</code> is used with <code>asciinema rec</code>),</li> <li>no limit if none of the above is present.</li> </ul>"},{"location":"manual/server/sharing/#theme","title":"theme","text":"<p>Use <code>theme</code> to override a theme used for the player's terminal.</p> <p>The available themes are:</p> <ul> <li>asciinema</li> <li>dracula</li> <li>monokai</li> <li>nord</li> <li>solarized-dark</li> <li>solarized-light</li> <li>tango</li> </ul> <p>Defaults to either:</p> <ul> <li>\"Terminal theme\" from the recording settings page,</li> <li>\"asciinema\" theme.</li> </ul>"},{"location":"manual/server/sharing/#poster","title":"poster","text":"<p>Use <code>poster</code> to specify an alternative poster (preview frame) to display in player's terminal until the playback is started.</p> <p>Currently only NPT (\"Normal Play Time\") notation is supported.</p> <p>For example, <code>poster=npt:1:23</code> will display a preview frame at 1 min 23 sec.</p> <p>Defaults to either:</p> <ul> <li>\"Thumbnail frame\" from the recording settings page,</li> <li>50% of the recording duration.</li> </ul>"},{"location":"manual/server/sharing/#cols","title":"cols","text":"<p>Use <code>cols</code> to override player's terminal width, i.e number of columns.</p> <p>Defaults to either:</p> <ul> <li>\"Terminal columns\" from the recording settings page,</li> <li>columns saved in the recording file.</li> </ul> <p>Warning</p> <p>Setting <code>cols</code> to a value smaller than the one from the original recording may break the rendering of sessions containing \"full screen\" programs like <code>vim</code>, <code>htop</code> or <code>less</code>. It's usually safe to override <code>cols</code> for recordings of basic command execution in a shell.</p>"},{"location":"manual/server/sharing/#rows","title":"rows","text":"<p>Use <code>rows</code> to override player's terminal height, i.e number of rows.</p> <p>Defaults to either:</p> <ul> <li>\"Terminal rows\" from the recording settings page,</li> <li>rows saved in the recording file.</li> </ul> <p>Warning</p> <p>The same caveat applies as with the <code>cols</code> option above.</p>"},{"location":"manual/server/sharing/#link-previews","title":"Link previews","text":"<p>asciinema server implements support for oEmbed, Open Graph, and Twitter Cards. When a recording link is shared on a social network or via a chat application, its preview is presented in a rich form. This includes a preview image, title and author information. It usually links back to your recording page.</p>"},{"location":"manual/server/streaming/","title":"Live streaming","text":"<p>asciinema server provides real-time terminal session broadcasting with minimal latency, enabling live streaming of terminal sessions to multiple viewers.</p> <p>The streaming system supports several application-level protocols with protocol negotiation. For simpler clients/use-cases it provides basic protocol auto-detection. Streaming is subject to configurable limits including per-user stream count restrictions and bandwidth rate limiting.</p> <p>Live terminal streaming is supported by asciinema CLI since version 3.0.</p>"},{"location":"manual/server/streaming/#architecture","title":"Architecture","text":"<p>The live streaming architecture follows a producer-consumer model with three key parties:</p> <pre><code>                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502   producer   \u2502\n                   \u2502    (CLI)     \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                         WS\n                          \u2502\n                          \u25bc\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502    relay     \u2502\n                   \u2502   (server)   \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u25b2      \u25b2      \u25b2\n                   /       \u2502       \\ \n                  WS      WS       WS\n                 /         \u2502         \\\n                /          \u2502          \\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   consumer   \u2502   \u2502   consumer   \u2502   \u2502   consumer   \u2502\n\u2502  (player 1)  \u2502   \u2502  (player 2)  \u2502   \u2502  (player 3)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The producer, typically asciinema CLI, captures terminal events and streams them to the producer endpoint (<code>/ws/S/&lt;producer-token&gt;</code>) on the server.</p> <p>The server acts as a relay, receiving events from producers and distributing them to consumers while maintaining the complete stream state.</p> <p>Consumers, such as asciinema player, connect to the consumer endpoint (<code>/ws/s/&lt;public-token&gt;</code>) on the server to receive real-time terminal events and display the live session.</p> <p>Both producer and consumer connections utilize WebSocket transport, implementing application-level protocols (WebSocket sub-protocols) for event transmission.</p> <p>The server maintains comprehensive state for each active stream by running the whole stream through asciinema's own virtual terminal emulator. This enables new consumers to connect mid-stream and immediately receive the current terminal view, ensuring a seamless viewing experience regardless of when viewers join the session.</p>"},{"location":"manual/server/streaming/#live-stream-lifecycle","title":"Live stream lifecycle","text":"<p>Before the producer can start sending stream events to the producer WebSocket endpoint, streams must be created and configured through the HTTP API. This two-phase approach separates stream management from real-time data transmission.</p> <p>The flow is as follows:</p> <ol> <li>create or update a stream with the    HTTP API, setting <code>{ \"live\": true }</code></li> <li>extract <code>ws_producer_url</code> from the JSON response</li> <li>open WebSocket connection to <code>ws_producer_url</code></li> <li>start sending terminal session events as WebSocket messages, encoded for the    selected sub-protocol (see Protocols section below)</li> </ol> <p>Marking a stream \"live\" is required for the producer endpoint to accept a WebSocket connection.</p> <p>The creation/update of a live stream (<code>{ \"live\": true }</code>) in the API may fail if given user's live stream limit has already been reached. See Limits below.</p> <p>When the WebSocket connection is closed gracefully, the server automatically marks the stream \"dead\" (<code>{ \"live\": false }</code>).</p> <p>When the connection is closed abruptly (e.g. a network issue), the server keeps the stream \"live\" for 60 sec, giving the producer grace time to reconnect before marking the stream \"dead\".</p> <p>After stream ends, if stream recording is enabled, a new recording is automatically created.</p> Example: creating a new stream and sending events PythonJavaScript <pre><code>import requests\nimport websocket\nimport base64\nimport json\n\n# Step 1: Create/update stream with HTTP API\ntoken = \"your-cli-token\"\nauth = base64.b64encode(f\":{token}\".encode()).decode()\n\nresponse = requests.post(\n    \"https://asciinema.org/api/v1/streams\",\n    headers={\"Authorization\": f\"Basic {auth}\"},\n    json={\"live\": True, \"title\": \"It's alive!\"}\n)\n\n# Step 2: Extract ws_producer_url\nstream_data = response.json()\nws_url = stream_data[\"ws_producer_url\"]\n\n# Step 3: Open WebSocket connection\nws = websocket.WebSocket()\nws.connect(ws_url, subprotocols=[\"v3.asciicast\"])\n\n# Step 4: Send terminal events (asciicast v3 format)\n# Header message\nheader = {\"version\": 3, \"term\": {\"cols\": 80, \"rows\": 24}}\nws.send(json.dumps(header))\n\n# Output event (1.0 second interval, output type, data)\noutput_event = [1.0, \"o\", \"Hello, World!\\n\"]\nws.send(json.dumps(output_event))\n</code></pre> <pre><code>import WebSocket from 'ws';\n\n// Step 1: Create/update stream with HTTP API\nconst token = 'your-cli-token';\nconst auth = Buffer.from(`:${token}`).toString('base64');\n\nconst response = await fetch('https://asciinema.org/api/v1/streams', {\n    method: 'POST',\n    headers: {\n        'Authorization': `Basic ${auth}`,\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ live: true, title: \"It's alive!\" })\n});\n\n// Step 2: Extract ws_producer_url\nconst streamData = await response.json();\nconst wsUrl = streamData.ws_producer_url;\n\n// Step 3: Open WebSocket connection\nconst ws = new WebSocket(wsUrl, ['v3.asciicast']);\n\n// Step 4: Send terminal events (asciicast v3 format)\nws.on('open', () =&gt; {\n    // Header message\n    const header = {\"version\": 3, \"term\": {\"cols\": 80, \"rows\": 24}};\n    ws.send(JSON.stringify(header));\n\n    // Output event (1.0 second interval, output type, data)\n    const outputEvent = [1.0, \"o\", \"Hello, World!\\n\"];\n    ws.send(JSON.stringify(outputEvent));\n});\n</code></pre>"},{"location":"manual/server/streaming/#protocols","title":"Protocols","text":"<p>There are several WebSocket-based protocols for different client capabilities and use cases:</p> Protocol Transport Sec-WebSocket-Protocol name Summary ALiS v1 binary WebSocket <code>v1.alis</code> Full-featured, lean, precise timing asciicast v2 text WebSocket <code>v2.asciicast</code> Full-featured, heavy, precise timing, easy to implement asciicast v3 text WebSocket <code>v3.asciicast</code> Full-featured, heavy, precise timing, easy to implement raw binary WebSocket <code>raw</code> Output-only, the leanest, no resize and other events, no accurate timing, easy to implement <p>Note</p> <p>We call them \"protocols\" because they're negotiated using standard <code>Sec-WebSocket-Protocol</code> header, but in practice they're just serialization formats as they're uni-directional.</p> <p>The producer endpoint supports all of the above. The consumer endpoint supports <code>ALiS v1</code> only  given its primary client is asciinema player, which has full support for this protocol.</p> <p>Upon connection a protocol is negotiated using Sec-WebSocket-Protocol header.</p> <p>If no <code>Sec-WebSocket-Protocol</code> header is provided by the client, the producer endpoint tries to detect the protocol from the first received message, falling back to <code>raw</code> if its heuristics fail.</p> <p>Info</p> <p>Consumers always receive ALiS v1 encoded stream regardless of the protocol the producer uses. The server handles protocol translation transparently.</p>"},{"location":"manual/server/streaming/#alis-v1","title":"ALiS v1","text":"<p>ALiS (Asciinema Live Stream) is the primary binary protocol supporting all session event types, while being lightweight on the wire. It's supported by asciinema CLI, server and player.</p> <p>Conceptually it's based on asciicast v3, but it's leaner and optimized for low latency live streaming.</p>"},{"location":"manual/server/streaming/#data-encoding","title":"Data encoding","text":"<p>ALiS uses LEB128 (Little Endian Base 128) encoding for all integers to minimize bandwidth. Currently only unsigned integers are in use by the protocol, so in practice it uses Unsigned LEB128 only.</p> <p>All text data uses UTF-8 encoding with length prefix:</p> <pre><code>String := [Length: LEB128][Data: UTF-8 bytes]\n</code></pre>"},{"location":"manual/server/streaming/#stream-structure","title":"Stream structure","text":"<p>The very first binary message sent right after opening a connection must be the 5 byte magic string:</p> <p><code>[0x41, 0x4C, 0x69, 0x53, 0x01]</code> - <code>\"ALiS\\x01\"</code> in ASCII.</p> <p>The messages following it represent an event stream. Each binary WebSocket message encodes a separate event:</p> <pre><code>Event  := [EventType: uint8][EventData]\n</code></pre> <p>Where:</p> <ul> <li>EventType: one of event types listed below</li> <li>EventData: event type specific payload</li> </ul>"},{"location":"manual/server/streaming/#event-types","title":"Event types","text":"<p>Init (0x01) - Initialize or reset stream state</p> <pre><code>[0x01][LastId: LEB128][Time: LEB128][Cols: LEB128][Rows: LEB128][Theme][InitData: String]\n</code></pre> <p>Where:</p> <ul> <li>LastId: event sequence number for synchronization</li> <li>RelTime: microseconds since the stream start (typically 0, may be positive when joining a stream as a consumer later)</li> <li>Cols/Rows: terminal size</li> <li>Theme: color theme (see Theme below)</li> <li>InitData: optional pre-existing terminal content, to bring the consumer up to speed with terminal state</li> </ul> <p>This event type is conceptually similar to the header in asciicast file format.</p> Example: Init with 80x24 terminal, no theme, \"Hello!\" initial data <pre><code>\\x01   \\x00   \\x00   \\x50   \\x18   \\x00   \\x06  Hello!\n^init  ^id    ^time  ^80    ^24    ^theme ^len  ^data\n</code></pre> <p>Output (0x6F) - Terminal output</p> <pre><code>[0x6F][Id: LEB128][RelTime: LEB128][Data: String]\n</code></pre> <p>Where:</p> <ul> <li>Id: event sequence number</li> <li>RelTime: microseconds since last event</li> <li>Data: terminal output text</li> </ul> Example: Output \"ls -la\\n\" after 125ms <pre><code>\\x6F   \\x01   \\xE8\\x07   \\x07   ls -la\\n\n^out   ^id1   ^125000\u03bcs  ^len   ^data\n</code></pre> <p>Input (0x69) - User (keyboard) input</p> <pre><code>[0x69][Id: LEB128][RelTime: LEB128][Data: String]\n</code></pre> <p>Where:</p> <ul> <li>Id: event sequence number  </li> <li>RelTime: microseconds since last event</li> <li>Data: user input text</li> </ul> Example: Input \"cd /tmp\" after 50ms <pre><code>\\x69   \\x02   \\x50\\xC3\\x00   \\x07  cd /tmp\n^inp   ^id2   ^50000\u03bcs       ^len  ^data\n</code></pre> <p>Resize (0x72) - Terminal window resize</p> <pre><code>[0x72][Id: LEB128][RelTime: LEB128][Cols: LEB128][Rows: LEB128]\n</code></pre> <p>Where:</p> <ul> <li>Id: event sequence number</li> <li>RelTime: microseconds since last event</li> <li>Cols/Rows: new terminal size</li> </ul> Example: Resize to 100x30 after 10ms <pre><code>\\x72   \\x03   \\x10\\x27   \\x64   \\x1E\n^res   ^id3   ^10000\u03bcs   ^100   ^30\n</code></pre> <p>Marker (0x6D) - Session annotations / bookmarking</p> <pre><code>[0x6D][Id: LEB128][RelTime: LEB128][Label: String]\n</code></pre> <p>Where:</p> <ul> <li>Id: event sequence number</li> <li>RelTime: microseconds since last event</li> <li>Label: human-readable marker description</li> </ul> Example: Marker with no label after 1s <pre><code>\\x6D   \\x04   \\x40\\x42\\x0F\\x00   \\x00\n^mrk   ^id4   ^1000000\u03bcs         ^len\n</code></pre> <p>Exit (0x78) - Process termination</p> <pre><code>[0x78][Id: LEB128][RelTime: LEB128][Status: LEB128]\n</code></pre> <p>Where:</p> <ul> <li>Id: event sequence number</li> <li>RelTime: microseconds since last event  </li> <li>Status: exit status code (non-negative)</li> </ul> <p>This event is typically sent as the last stream event, once the process that's being streamed (e.g. shell) exits.</p> Example: Exit with status 0 after 500ms <pre><code>\\x78   \\x05   \\xA0\\x86\\x01\\x00   \\x00\n^exit  ^id5   ^500000\u03bcs          ^status\n</code></pre> <p>EOT (0x04) - End of Transmission</p> <pre><code>[0x04][RelTime: LEB128]\n</code></pre> <p>Where:</p> <ul> <li>RelTime: microseconds since last event</li> </ul> <p>This event may be used to signal the stream end without closing the connection. Once EOT is received, the connection state goes back to post-magic-string pre-init state, expecting Init event to restart the stream from scratch.</p> <p>It's sent from the consumer endpoint whenever a producer ends the stream. This allows asciinema player (consumer) to keep the connection open and be ready for instant stream restart. This approach eliminates the need for an additional channel between the server and the consumer for checking stream liveness (such as another WebSocket or polling).</p> Example: EOT after 1s <pre><code>\\x04   \\x40\\x42\\x0F\\x00\n^eot   ^1000000\u03bcs\n</code></pre>"},{"location":"manual/server/streaming/#theme","title":"Theme","text":"<p>Terminal theme is encoded as follows:</p> <pre><code>Theme := [Format: uint8][ColorData?]\n</code></pre> <p>Where Format determines the presence and structure of ColorData:</p> <ul> <li><code>0x00</code> (no theme): no ColorData follows, only the format byte</li> <li><code>0x08</code> (8-color palette): ColorData with 8-color palette</li> <li><code>0x10</code> (16-color palette): ColorData with 16-color palette</li> </ul> <p>When ColorData is present (format <code>0x08</code> or <code>0x10</code>):</p> <pre><code>ColorData := [Fg: RGB][Bg: RGB][Palette: N\u00d7RGB]\nRGB := [R: uint8][G: uint8][B: uint8]\n</code></pre> <p>Where N is 8 or 16 depending on format identifier.</p> Theme examples <p>No theme (format 0x00):</p> <pre><code>\\x00\n^no theme\n</code></pre> <p>8-color palette (format 0x08):</p> <pre><code>\\x08   \\xD0\\xD0\\xD0   \\x1C\\x1C\\x1C   \\x00\\x00\\x00\\xFF\\x00\\x00 ... (6 more colors)\n^8col  ^fg(gray)      ^bg(dark)      ^palette                 ...\n</code></pre> <p>16-color palette (format 0x10):</p> <pre><code>\\x10   \\xD0\\xD0\\xD0   \\x1C\\x1C\\x1C   \\x00\\x00\\x00\\xFF\\x00\\x00 ... (14 more colors)\n^16col ^fg(gray)      ^bg(dark)      ^palette                  ...\n</code></pre>"},{"location":"manual/server/streaming/#asciicast-v2","title":"asciicast v2","text":"<p>This is just asciicast v2 file format sent via WebSocket, where each line is delivered as a separate text message.</p> <p>It's simple, so creating a client is rather easy. However, it's much more bandwidth heavy than ALiS, and it doesn't provide a mechanism to sync the server with the client's recent state upon re-connections (like ALiS does).</p> Example: asciicast v2 streaming with asciinema 2.x and websocat <p>This is an example of streaming with asciinema CLI 2.x, which doesn't natively support streaming. Thankfully, it writes recordings in asciicast v2 format!</p> <p>The example also uses <code>curl</code>, <code>jq</code> and <code>websocat</code>.</p> <pre><code># obtain install ID\nINSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\n# create stream and capture JSON response\nresponse=$(curl -s -X POST \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"live\": true}' \\\n  https://asciinema.org/api/v1/streams)\n\n# extract WebSocket producer URL\nurl=$(echo \"$response\" | jq -r '.ws_producer_url')\n\n# create named pipe, for connecting the CLI with websocat\nmkfifo live.fifo\n\n# run websocat to stream from the pipe to the producer URL\nwebsocat --text $url &lt; live.fifo\n\n# in another terminal start asciinema recording session\nasciinema rec live.fifo\n</code></pre>"},{"location":"manual/server/streaming/#asciicast-v3","title":"asciicast v3","text":"<p>This is just asciicast v3 file format sent via WebSocket, where each line is delivered as a separate text message.</p> <p>Same pros/cons as mentioned for v2 apply here.</p> Example: asciicast v3 streaming with asciinema 3.x and websocat <p>This is an example of alternative way of streaming with asciinema CLI 3.x. CLI 3.0+ supports streaming natively using ALiS protocol (<code>asciinema stream</code> / <code>asciinema session</code>), which should be always preferred.</p> <p>Here is just an example of feeding asciicast v3 stream into the producer endpoint. The example also uses <code>curl</code>, <code>jq</code> and <code>websocat</code>.</p> <pre><code># obtain install ID\nINSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\n# create stream and capture JSON response\nresponse=$(curl -s -X POST \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"live\": true}' \\\n  https://asciinema.org/api/v1/streams)\n\n# extract WebSocket producer URL\nurl=$(echo \"$response\" | jq -r '.ws_producer_url')\n\n# create named pipe, for connecting the CLI with websocat\nmkfifo live.fifo\n\n# run websocat to stream from the pipe to the producer URL\nwebsocat --text $url &lt; live.fifo\n\n# in another terminal start asciinema recording session\nasciinema rec -f asciicast-v3 live.fifo\n</code></pre>"},{"location":"manual/server/streaming/#raw","title":"raw","text":"<p>This protocol is just raw binary messages representing direct terminal output, without any additional encoding/metadata.</p> <p>The whole binary stream is treated as session output to be fed into a terminal. That includes both printable characters and control sequences.</p> <p>There's no support for input, resize, marker and other event types. Terminal theme reproduction is also not possible when using this protocol.</p> <p>Given the messages don't include timing information, server-side time of arrival is used for timing each output event. That means, the original fine-grained timing of the session is lost, and playback smoothness is highly susceptible to network conditions.</p> <p>The terminal size is assumed to be 80x24. However, the first received message is inspected for size hints.</p> <p>If the escape sequence <code>\\e[8;Y;Xt</code> is found then <code>Y</code> is assumed to be terminal height in rows, and <code>X</code> is assumed to be terminal width in columns. This sequence is injected by termrec for example.</p> <p>Another size hint that the server looks for is script start message, which typically includes <code>COLUMNS=\"..\" LINES=\"..\"</code>.</p> Example: raw streaming with script and websocat <p>This is an example of streaming with script. <code>script</code> writes the captured terminal output as raw, binary data. The example also uses <code>curl</code>, <code>jq</code> and <code>websocat</code>.</p> <pre><code># obtain install ID\nINSTALL_ID=$(cat ~/.config/asciinema/install-id)\n\n# create stream and capture JSON response\nresponse=$(curl -s -X POST \\\n  -u \":${INSTALL_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"live\": true}' \\\n  https://asciinema.org/api/v1/streams)\n\n# extract WebSocket producer URL\nurl=$(echo \"$response\" | jq -r '.ws_producer_url')\n\n# create named pipe, for connecting the CLI with websocat\nmkfifo live.fifo\n\n# run websocat to stream from the pipe to the producer URL\nwebsocat --binary $url &lt; live.fifo\n\n# in another terminal start recording with script\nscript -f -O live.fifo\n</code></pre>"},{"location":"manual/server/streaming/#recording","title":"Recording","text":"<p>asciinema server can automatically record every live stream, converting them into regular recordings that can be replayed later. This allows streams to serve dual purposes: real-time broadcasting and permanent archival.</p> <p>Recording behavior is controlled by the <code>STREAM_RECORDING</code> environment variable.</p> <p>When recording is enabled, the complete terminal session is captured and stored as a regular recording.</p> <p>Recent recordings made from a stream are listed on a given stream page. All stream recordings are accessible from user profile page (visibility subject to related settings in user account).</p> <p>For detailed configuration options, see the Configuration documentation.</p> Stream recording on asciinema.org <p>Currently, stream recording is disabled on asciinema.org.</p>"},{"location":"manual/server/streaming/#limits","title":"Limits","text":"<p>The streaming system enforces two types of limits to manage server resources and prevent abuse:</p>"},{"location":"manual/server/streaming/#per-user-live-stream-count","title":"Per-user live stream count","text":"<p>By default, users can create unlimited number of streams. This can be restricted system-wide through use <code>DEFAULT_STREAM_LIMIT</code> config option (see the Configuration documentation), and individually per-user in the admin panel.</p> Live streams limit on asciinema.org <p>Currently, per-user live stream limit on asciinema.org is 1.</p>"},{"location":"manual/server/streaming/#bandwidth-limiting","title":"Bandwidth limiting","text":"<p>Each producer connection is subject to bandwidth rate limiting using token bucket algorithm to prevent individual connections from overwhelming the server while maintaining fair resource allocation across all active streams.</p> <p>The algorithm is configured such that:</p> <ul> <li>1 token == 1 byte of each received WebSocket message</li> <li>bucket size (capacity per connection) is 60 000 000 (60 MB) - this is maximum and initial value</li> <li>every 100 milliseconds the bucket is refilled with 10 000 tokens</li> </ul> <p>This gives headroom for short bursts, and allows sustained bandwidth of 100 KB/s.</p> <p>When the token bucket is exhausted, the connection is closed with error code 4004 (\"Bandwidth Exceeded\").</p>"},{"location":"manual/server/self-hosting/","title":"Self-hosting","text":"<p>While asciinema.org is the default asciinema server used by the CLI for uploading recordings, you can self-host your own instance if you want full ownership and control over the recordings.</p> <p>asciinema server is self-hosting friendly, and can be deployed both for public or internal/private use in any containerized environment using the official OCI image, ghcr.io/asciinema/asciinema-server.</p> <p>Requirements:</p> <ul> <li>OCI runtime, e.g. Docker,   Podman, Kubernetes</li> <li>512 MB of RAM minimum (for a personal instance), 1 GB recommended (for a   community/company instance)</li> <li>PostgreSQL 14.0+ database server</li> <li>SMTP server, either a dedicated service or an SMTP endpoint of your email   provider</li> </ul> <p>To get started, follow the quick start guide, which provides a template for a standard asciinema server configuration using docker-compose. This configuration includes a PostgreSQL container and supports HTTPS, allowing you to set up a complete, secure asciinema server easily.</p> <p>Once your server is up and running, you'll be able to upload your recordings by pointing asciinema CLI to the server using the <code>ASCIINEMA_SERVER_URL</code> environment variable:</p> CLI 3.xCLI 2.x <pre><code>export ASCIINEMA_SERVER_URL=https://asciinema.example.com\nasciinema upload demo.cast\n</code></pre> <pre><code>export ASCIINEMA_API_URL=https://asciinema.example.com\nasciinema upload demo.cast\n</code></pre> <p>If you need help with installation or maintenance feel free to ask on asciinema forum or in asciinema Matrix room.</p> <p>Last but not least, if your company is interested in having the installation, maintenance or customization of the server performed by the people who created asciinema, then check out asciinema consulting services.</p>"},{"location":"manual/server/self-hosting/admin/","title":"Administration","text":"<p>asciinema server provides admin panel on port 4002, separate from the main, user-facing web interface.</p> <p>To be able to access the admin panel when deploying the container make sure this port is exposed.</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    ports:\n      - '4002:4002'\n</code></pre> <p>Danger</p> <p>At the moment the admin endpoint doesn't perform any form of authentication/authorization so do not expose this port directly to the internet when running a public asciinema server instance.</p>"},{"location":"manual/server/self-hosting/configuration/","title":"Configuration","text":""},{"location":"manual/server/self-hosting/configuration/#general","title":"General","text":""},{"location":"manual/server/self-hosting/configuration/#base-url","title":"Base URL","text":"<p>The base URL of the server is configured with the following environment variables:</p> <ul> <li><code>URL_HOST</code> - the hostname (domain) of the server, defaults to <code>localhost</code></li> <li><code>URL_PORT</code> - the port it's accessible at, defaults to <code>4000</code></li> <li><code>URL_SCHEME</code> - the URL scheme, defaults to <code>http</code></li> </ul> HTTPHTTPS <p>In HTTP-only configuration it may look like this:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    ports:\n      - '80:4000'\n    environment:\n      - URL_HOST=asciinema.example.com\n      - URL_PORT=80\n      # ...\n</code></pre> <p>The IP address of the server may also be used as the hostname:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    ports:\n      - '80:4000'\n    environment:\n      - URL_HOST=192.168.10.20\n      - URL_PORT=80\n      # ...\n</code></pre> <p>In HTTPS configuration it may look like this:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      - URL_HOST=asciinema.example.com\n      - URL_SCHEME=https\n      # ...\n</code></pre> <p>Setting <code>URL_SCHEME=https</code> automatically sets the port to 443. This can be overridden by setting <code>URL_PORT</code> explicitly.</p> <p>For a complete HTTPS setup see HTTPS.</p> <p>To verify the URL configuration, start the server, open the logs, and search for a line that looks like this:</p> <pre><code>Access AsciinemaWeb.Endpoint at http://asciinema.example.com\n</code></pre> <p>It should reflect the <code>URL_*</code> settings.</p>"},{"location":"manual/server/self-hosting/configuration/#secret-key-base","title":"Secret key base","text":"<p>The <code>SECRET_KEY_BASE</code> environment variable is used for cryptographic operations, such as signing and verification of session cookies. It must be set to a string of 64 (or more) random characters.</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      - SECRET_KEY_BASE=...\n      # ...\n</code></pre> <p>One way to generate it is to use the following shell command:</p> <pre><code>tr -dc A-Za-z0-9 &lt;/dev/urandom | head -c 64; echo\n</code></pre> <p>Info</p> <p>While the server will start without the <code>SECRET_KEY_BASE</code> variable set (as we've seen in getting started guide), the login sessions won't survive the <code>asciinema</code> container restart without it.</p>"},{"location":"manual/server/self-hosting/configuration/#signup","title":"Signup","text":"<p>By default anyone can sign up for a user account on asciinema server. Setting <code>SIGN_UP_DISABLED=true</code> disables public signups, allowing login for existing users only.</p> <p>A typical use-case for disabling signup is a personal server. After creating a user account for yourself, you can lock the server down, effectively making it a single-user asciinema server.</p>"},{"location":"manual/server/self-hosting/configuration/#avatars","title":"Avatars","text":"<p>User avatars are automatically generated based on user email. By default identicon-like avatars are used.</p> <p>If you prefer to use Gravatar then set <code>DEFAULT_AVATAR=gravatar</code>.</p>"},{"location":"manual/server/self-hosting/configuration/#admin-contact-email","title":"Admin contact email","text":"<p>When setting up a public instance of asciinema server, it's advised to set <code>CONTACT_EMAIL_ADDRESS</code> to the email address of the person who manages the server, i.e. you.</p> <p>The contact email address is displayed on server's <code>/about</code> page, which is linked from the footer. Having it lets users of your asciinema server to reach you when facing issues.</p> <p>Here is one on asciinema.org.</p>"},{"location":"manual/server/self-hosting/configuration/#database","title":"Database","text":"<p>asciinema server utilizes a PostgreSQL database for storing recording metadata and user account information, among other data.</p> <p>The <code>DATABASE_URL</code> environment variable configures the database connection. It uses the standard format of <code>postgresql://username:password@hostname:port/dbname</code>. Port number can be omitted when connecting to the standard PostgreSQL port 5432.</p>"},{"location":"manual/server/self-hosting/configuration/#postgresql-container","title":"PostgreSQL container","text":"<p>If you don't have an existing PostgreSQL server, the easiest way to get one running is to use the official PostgreSQL OCI image. Here's an example:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    depends_on:\n      postgres:\n        condition: service_healthy\n\n  postgres:\n    image: docker.io/library/postgres:14\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_HOST_AUTH_METHOD=trust\n    healthcheck:\n      test: ['CMD-SHELL', 'pg_isready -U postgres']\n      interval: 2s\n      timeout: 5s\n      retries: 10\n\nvolumes:\n  postgres_data:\n</code></pre> <p>asciinema server container image uses a default value <code>postgresql://postgres@postgres/postgres</code> for <code>DATABASE_URL</code>, enabling it to connect to the <code>postgres</code> container automatically.</p> <p>The <code>postgres</code> container runs PostgreSQL server with the authentication method set to <code>trust</code>, effectively disabling authentication. Generally, this approach is not recommended.  However, in our setup, this configuration is acceptable, because the database is only accessible internally by the <code>asciinema</code> container (we don't expose the <code>postgres</code> port on the host machine).</p> <p>By using <code>depends_on</code> with <code>service_healthy</code> condition we ensure the <code>asciinema</code> container is started only after database health-checks pass. This is to prevent asciinema server's boot procedure crashing while the database is still initializing.</p> <p>We used volume mapping for PostgreSQL's data directory, but you can also bind-mount it to a directory on the host system like this:</p> docker-compose.yml<pre><code>services:\n  # ...\n\n  postgres:\n    image: docker.io/library/postgres:14\n    volumes:\n      - /path/to/postgres/data:/var/lib/postgresql/data\n</code></pre> <p>Tip</p> <p>Don't forget to set up an automated backup of this directory!</p>"},{"location":"manual/server/self-hosting/configuration/#external-postgresql-server","title":"External PostgreSQL server","text":"<p>If you have an existing PostgreSQL server (14 or higher), set the <code>DATABASE_URL</code> environment variable accordingly:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      - DATABASE_URL=postgresql://username:password@hostname/dbname\n</code></pre> <p>The connection URL supports the following extra parameters after <code>?</code> at the end of the connection string:</p> <ul> <li><code>ssl=true</code> - enable connection encryption, defaults to <code>false</code></li> <li><code>pool_size=N</code> - set the size of the connection pool, defaults to 10</li> </ul> <p>For example, to connect to the server at 10.9.8.7 as user <code>asciinema</code> using encrypted connection, setting the connection pool size to 2, use the following URL:</p> <pre><code>DATABASE_URL=postgresql://asciinema:xxx@10.9.8.7/asciinema?ssl=true&amp;pool_size=2\n</code></pre> <p>The database user (<code>asciinema</code>) must have full write permissions to this database (<code>asciinema</code>), including the ability to make any schema changes, such as <code>CREATE/ALTER/DROP TABLE/COLUMN</code>.</p>"},{"location":"manual/server/self-hosting/configuration/#file-store","title":"File store","text":"<p>asciinema server stores uploaded asciicast files in a configured file store. By default it utilizes the local filesystem, but one can use any S3-compatible object store, such as AWS S3, Cloudflare R2, or a self-hosted MinIO server.</p>"},{"location":"manual/server/self-hosting/configuration/#local-filesystem","title":"Local filesystem","text":"<p>With the local filesystem used as the file store, the files are saved in <code>/var/lib/asciinema</code>. Mapping this directory to a volume is necessary for data persistence:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    volumes:\n      - asciinema_data:/var/lib/asciinema\n\nvolumes:\n  asciinema_data:\n</code></pre> <p>Alternatively, you can bind-mount it to a directory on the host system like this:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    volumes:\n      - /path/to/asciinema/data:/var/lib/asciinema\n</code></pre> <p>Tip</p> <p>Similarly to the database data directory, it's advised to set up automated backup for this one too.</p>"},{"location":"manual/server/self-hosting/configuration/#aws-s3","title":"AWS S3","text":"<p>To use AWS S3 for file storage, set the following environment variables for the <code>asciinema</code> container, adjusted accordingly:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      - S3_BUCKET=your-asciinema-bucket\n      - S3_ACCESS_KEY_ID=your-aws-access-key-id\n      - S3_SECRET_ACCESS_KEY=your-aws-secret-access-key\n      - S3_REGION=us-east-1\n</code></pre>"},{"location":"manual/server/self-hosting/configuration/#cloudflare-r2","title":"Cloudflare R2","text":"<p>R2 is an S3-compatible object store offered by Cloudflare. To use R2 for file storage set the following environment variables for the <code>asciinema</code> container:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      - S3_BUCKET=your-asciinema-bucket\n      - S3_ENDPOINT=https://&lt;ACCOUNT_ID&gt;.r2.cloudflarestorage.com\n      - S3_ACCESS_KEY_ID=your-r2-access-key-id\n      - S3_SECRET_ACCESS_KEY=your-r2-secret-access-key\n      - S3_REGION=auto\n</code></pre> <p>Refer to the R2 documentation for information on obtaining the account ID and the access key.</p>"},{"location":"manual/server/self-hosting/configuration/#email","title":"Email","text":"<p>asciinema server needs an email server/service to deliver emails containing short-lived login links.</p> <p>When no SMTP server is configured, no mail is sent. However, you can obtain a login link from the server container logs after entering your email address on the login page. Search for a line containing a URL, and open that URL in a browser. This is fine for testing, or a single-user server, but for a multi-user setup SMTP is necessary.</p> <p>SMTP settings are configured with <code>SMTP_*</code> set of environment variables. The main ones are <code>SMTP_HOST</code>, <code>SMTP_USERNAME</code> and <code>SMTP_PASSWORD</code>.</p> <p>For example:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      # ...\n      - SMTP_HOST=smtp.example.com\n      - SMTP_USERNAME=foobar\n      - SMTP_PASSWORD=hunter2\n</code></pre> <p>Here's a complete list of available SMTP settings:</p> <ul> <li><code>SMTP_HOST</code> - required</li> <li><code>SMTP_PORT</code> - defaults to 587</li> <li><code>SMTP_USERNAME</code> - usually required by the SMTP server</li> <li><code>SMTP_PASSWORD</code> - usually required by the SMTP server</li> <li><code>SMTP_TLS</code> - set to <code>always</code>, <code>never</code> or <code>if_available</code>, defaults to <code>if_available</code></li> <li><code>SMTP_ALLOWED_TLS_VERSIONS</code> - set allowed TLS versions, defaults to <code>tlsv1,tlsv1.1,tlsv1.2</code></li> <li><code>SMTP_AUTH</code> - set to <code>always</code> or <code>if_available</code>, defaults to <code>if_available</code></li> <li><code>SMTP_NO_MX_LOOKUPS</code> - set to <code>true</code> to disable MX lookups and connect directly to the server of recipient's domain</li> </ul> <p>Additionally, following variables can be used to adjust the mail headers:</p> <ul> <li><code>MAIL_FROM_ADDRESS</code> - address for the <code>From</code> header, defaults to <code>hello@$URL_HOST</code></li> <li><code>MAIL_REPLY_TO_ADDRESS</code> - address for the <code>Reply-To</code> header, defaults to <code>admin@$URL_HOST</code></li> </ul> <p>Below you'll find example SMTP configurations for selected providers.</p> <p>You can test your configuration by sending a test email using the following command:</p> <pre><code>docker compose exec asciinema send-test-email your@email.example.com\n</code></pre>"},{"location":"manual/server/self-hosting/configuration/#fastmail","title":"Fastmail","text":"docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      # ...\n      - SMTP_HOST=smtp.fastmail.com\n      - SMTP_USERNAME=your-username@fastmail.com\n      - SMTP_PASSWORD=your-fastmail-app-password\n</code></pre> <p>You need to use an \"app password\" instead of your regular Fastmail account password. You can generate one on Fastmail's settings page, in the Privacy &amp; Security -&gt; Integrations section. Check Fastmail SMTP docs for further information.</p>"},{"location":"manual/server/self-hosting/configuration/#gmail","title":"Gmail","text":"docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      # ...\n      - SMTP_HOST=smtp.gmail.com\n      - SMTP_USERNAME=your-username@gmail.com\n      - SMTP_PASSWORD=your-gmail-app-password\n</code></pre> <p>You need to use an \"app password\" instead of your regular Google account password. Check Google app passwords docs for further information.</p>"},{"location":"manual/server/self-hosting/configuration/#mailgun","title":"Mailgun","text":"docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      # ...\n      - SMTP_HOST=smtp.mailgun.org\n      - SMTP_USERNAME=postmaster@mg.your.domain\n      - SMTP_PASSWORD=your-mailgun-password\n</code></pre> <p>Check Mailgun SMTP docs for instructions on how to obtain SMTP credentials.</p>"},{"location":"manual/server/self-hosting/configuration/#aws-ses","title":"AWS SES","text":"docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      # ...\n      - SMTP_HOST=email-smtp.eu-west-1.amazonaws.com\n      - SMTP_USERNAME=your-ses-smtp-username\n      - SMTP_PASSWORD=your-ses-smtp-password\n</code></pre> <p>Check AWS SES SMTP docs for instructions on how to obtain SMTP credentials.</p>"},{"location":"manual/server/self-hosting/configuration/#https","title":"HTTPS","text":"<p>Implementing HTTPS for asciinema server is typically done by putting a reverse proxy, a web server, or a cloud provider's load balancer in front of it. A web server, such as Nginx or Apache, combined with Let's Encrypt can be used for that.</p> <p>Regardless of the solution, asciinema server needs to know that you're using HTTPS, which is done by setting the <code>URL_SCHEME=https</code> environment variable.</p>"},{"location":"manual/server/self-hosting/configuration/#caddy","title":"Caddy","text":"<p>The easiest solution is to use Caddy web server in reverse proxy mode. For example:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    environment:\n      # ...\n      - URL_HOST=asciinema.example.com\n      - URL_SCHEME=https\n\n  caddy:\n    image: caddy:2\n    command: caddy reverse-proxy --from https://asciinema.example.com --to http://asciinema:4000\n    ports:\n      - '80:80'\n      - '443:443'\n      - '443:443/udp'\n    volumes:\n      - caddy_data:/data\n      - caddy_config:/config\n\nvolumes:\n  # ...\n  caddy_data:\n  caddy_config:\n</code></pre> <p>The command <code>caddy reverse-proxy --from https://asciinema.example.com --to http://asciinema:4000</code> tells Caddy to obtain and automatically renew a TLS certificate for the <code>asciinema.example.com</code> domain, terminate the TLS connections on port 443, and forward the requests to the <code>asciinema</code> container on port <code>4000</code>.</p> <p>The DNS record for your server must match the <code>URL_HOST</code>, and the Caddy <code>--from</code> argument must use the same domain too.</p> <p>Warning</p> <p>Before starting Caddy ensure ports 80 and 443 are open to the internet, and that a DNS record already points to your server's IP. Otherwise Caddy won't be able to perform the HTTP challenge when requesting a certificate from Let's Encrypt, which could risk a temporary ban for this IP.</p>"},{"location":"manual/server/self-hosting/configuration/#other-reverse-proxy","title":"Other reverse proxy","text":"<p>If you prefer to use something else for TLS termination then you need to forward the HTTP requests to port <code>4000</code> of the <code>asciinema</code> container. This requires mapping the port <code>4000</code> on the host machine:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    ports:\n      - '4000:4000'\n    environment:\n      # ...\n      - URL_HOST=asciinema.example.com\n      - URL_SCHEME=https\n</code></pre> <p>With <code>URL_SCHEME=https</code>, a default HTTPS port 443 is assumed. If you need to use another port, use <code>URL_PORT</code> variable, e.g <code>URL_PORT=8443</code>.</p>"},{"location":"manual/server/self-hosting/configuration/#uploads","title":"Uploads","text":""},{"location":"manual/server/self-hosting/configuration/#authentication","title":"Authentication","text":"<p>By default uploading with <code>asciinema upload</code> doesn't require authentication via <code>asciinema auth</code>, meaning anyone can upload new recordings. This is useful in trusted environments, such as private LANs/homelabs. If you run a public asciinema server instance, or prefer to disable unauthenticated uploads for other reasons, then set <code>UPLOAD_AUTH_REQUIRED=true</code>.</p>"},{"location":"manual/server/self-hosting/configuration/#recording-visibility","title":"Recording visibility","text":"<p>Recording visibility for newly uploaded recordings is inherited from user-level \"Recording visibility\" setting. It can be changed for every recording individually at any time.</p> <p>The default for user's \"Recording visibility\" setting is Unlisted. This default can be changed with <code>DEFAULT_RECORDING_VISIBILITY</code> environment variable, which accepts either <code>public</code>, <code>unlisted</code>, <code>private</code>.</p>"},{"location":"manual/server/self-hosting/configuration/#upload-path-template","title":"Upload path template","text":"<p>Uploaded recordings are saved in the file store at a path specified by <code>UPLOAD_PATH_TPL</code> environment variable, which defaults to <code>recordings/{username}/{year}/{month}/{day}/{id}.{ext}</code>. If you prefer a different directory structure then set this variable. The following placeholders are supported:</p> <ul> <li><code>{id}</code> - numerical (native) ID of a recording</li> <li><code>{username}</code> - username of the recording's author</li> <li><code>{shard}</code> - 2 level deep directory shard based on numerical ID of a recording</li> <li><code>{ext}</code> - recording file extension, <code>cast</code> for asciicast v2 and v3, <code>json</code> for asciicast v1</li> <li><code>{year}</code>, <code>{month}</code>, <code>{day}</code> - current date</li> </ul> <p>Changing the value of <code>UPLOAD_PATH_TPL</code> when you have existing recordings is safe. The server automatically migrates the files to their new locations via a background job, which runs daily.</p>"},{"location":"manual/server/self-hosting/configuration/#upload-size-limit","title":"Upload size limit","text":"<p>The default size limit for the uploaded recordings is 8 MB. This can be raised by setting <code>UPLOAD_SIZE_LIMIT</code> variable to the desired limit, in bytes. For example, <code>UPLOAD_SIZE_LIMIT=16000000</code> changes the limit to 16 MB.</p>"},{"location":"manual/server/self-hosting/configuration/#unclaimed-recordings-removal","title":"Unclaimed recordings removal","text":"<p>When a recording is uploaded with <code>asciinema upload</code> from a new system, it's not linked to any user account, unless <code>asciinema auth</code> was used to authenticate the CLI with the server (either before or after the upload). By default, such \"unclaimed\" recordings, are kept forever on a self-hosted asciinema server.</p> <p>To enable automatic \"garbage collection\" for unclaimed recordings, use <code>UNCLAIMED_RECORDING_TTL</code> variable, set to the number of days after which each unclaimed recording should be deleted. For example, <code>UNCLAIMED_RECORDING_TTL=30</code> tells the server to keep every unclaimed recording for up to 30 days, and after that, delete it permanently.</p> <p>Setting <code>UNCLAIMED_RECORDING_TTL</code> to a tuple, e.g. <code>UNCLAIMED_RECORDING_TTL=7,30</code>, where the first number (<code>7</code>) is a TTL for soft-deletion and the second number (<code>30</code>) is a TTL for hard (permanent) deletion, enables a 2-step removal process. In this mode, the recording is marked as deleted and hidden after the soft-deletion TTL period (7 days in this example). Then, after the hard-deletion TTL period (30 days in this example), it's permanently deleted from the database and the filesystem/object store.</p>"},{"location":"manual/server/self-hosting/configuration/#streaming","title":"Streaming","text":"<p>Live streaming feature is enabled by default for all users.</p> <p>You can disable streaming for each user individually in the admin panel.</p> <p>If you'd rather disable streaming for everyone by default then set <code>DEFAULT_STREAMING_ENABLED=false</code>. Changing this doesn't affect existing users though, so you may still want to turn streaming off manually for each existing user.</p>"},{"location":"manual/server/self-hosting/configuration/#stream-recording","title":"Stream recording","text":"<p>asciinema server can automatically save every live stream into a regular recording.</p> <p>This behaviour is controlled via <code>STREAM_RECORDING</code> environment variable, which accepts the following values:</p> <ul> <li><code>allowed</code> (default) - let each user control whether recording is enabled/disabled</li> <li><code>forced</code> - always record every stream, disables user-level control</li> <li><code>disabled</code> - disable stream recording system-wide</li> </ul>"},{"location":"manual/server/self-hosting/configuration/#stream-visibility","title":"Stream visibility","text":"<p>Stream visibility for newly created streams is inherited from user-level \"Stream visibility\" setting. It can be changed for every stream individually at any time.</p> <p>The default for user's \"Stream visibility\" setting is Unlisted. This default can be changed with <code>DEFAULT_STREAM_VISIBILITY</code> environment variable, which accepts either <code>public</code>, <code>unlisted</code>, <code>private</code>.</p>"},{"location":"manual/server/self-hosting/configuration/#stream-limit","title":"Stream limit","text":"<p>By default, there's no limit to the number of live streams a user can have. </p> <p>You can set a limit for each user individually in the admin panel.</p> <p>If you'd rather set a stream limit for everyone by default then set <code>DEFAULT_STREAM_LIMIT</code> to the maximum number of streams. Note that changing/setting the default limit only affects new users - existing users retain their current limits and must be updated individually in the admin panel.</p>"},{"location":"manual/server/self-hosting/configuration/#advanced-configuration","title":"Advanced configuration","text":"<p>Usually the environment variables described earlier are sufficient to configure asciinema server to suit your needs.</p> <p>In special cases you may want to hook into Phoenix framework runtime configuration in order to override certain settings found in the server's config directory.</p> <p>To do that, create <code>custom.exs</code> file containing configuration overrides, then bind-mount the file at <code>/opt/app/etc/custom.exs</code> in the container:</p> custom.exs<pre><code>import Config\n\nconfig :asciinema,\n  foo: 123,\n  bar: \"baz\"\n</code></pre> docker-compose.yml<pre><code>services:\n  asciinema:\n    # ...\n    volumes:\n      - asciinema_data:/var/lib/asciinema\n      - ./custom.exs:/opt/app/etc/custom.exs\n    # ...\n</code></pre> <p>If the changes you'd like to make are not possible through the configuration, check how to customize the server by changing its source code and building a custom container image. This may require a bit of Elixir/Phoenix knowledge though.</p> <p>For non-trivial customizations you may want to consider using asciinema consulting services.</p>"},{"location":"manual/server/self-hosting/configuration/#custom-tls-client-certificate","title":"Custom TLS client certificate","text":"<p>In case your S3 server is secured with a self-signed certificate, it is possible to configure the S3 library http client to use a custom CA certificate file. This can be done with the <code>custom.exs</code> file mentioned above, with the following configuration:</p> custom.exs<pre><code>import Config\n\nconfig :ex_aws, :hackney_opts,\n  ssl_options: [\n    verify: :verify_peer,\n    cacertfile: \"/usr/local/share/ca-certificates/truststore.pem\"\n  ]\n</code></pre>"},{"location":"manual/server/self-hosting/customization/","title":"Customization","text":"<p>In cases where the regular configuration is not enough, you can build a custom asciinema server image. The server is built with Elixir language and Phoenix framework. While not mainstream, this stack is easy to work with.</p> <p>Let's take log level as an example. We'll change it from the default <code>:info</code> to more quiet <code>:warning</code>.</p>"},{"location":"manual/server/self-hosting/customization/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/asciinema/asciinema-server.git\n</code></pre>"},{"location":"manual/server/self-hosting/customization/#create-a-new-branch","title":"Create a new branch","text":"<pre><code>git checkout main\ngit switch -c custom\n</code></pre>"},{"location":"manual/server/self-hosting/customization/#make-the-changes","title":"Make the changes","text":"<p>Edit <code>config/prod.exs</code> file, applying this change:</p> <pre><code>- config :logger, level: :info\n+ config :logger, level: :warning\n</code></pre> <p>Then, commit the changes.</p>"},{"location":"manual/server/self-hosting/customization/#rebuild-the-image","title":"Rebuild the image","text":"<pre><code>docker build -t ghcr.io/asciinema/asciinema-server:custom .\n</code></pre>"},{"location":"manual/server/self-hosting/customization/#update-the-image-tag","title":"Update the image tag","text":"<p>Update the <code>asciinema</code> container image tag to <code>custom</code>:</p> docker-compose.yml<pre><code>services:\n  asciinema:\n-   image: ghcr.io/asciinema/asciinema-server:20250915\n+   image: ghcr.io/asciinema/asciinema-server:custom\n</code></pre>"},{"location":"manual/server/self-hosting/customization/#launch-the-new-version","title":"Launch the new version","text":"<p>Finally, recreate the stack by running:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"manual/server/self-hosting/quick-start/","title":"Quick start","text":"<p>This guide shows how to setup your own instance of asciinema server for hosting terminal session recordings.</p> <p>For a broader overview of what's possible with asciinema check out the intro guide.</p> <p>To keep this guide simple we'll use the official asciinema server container image, ghcr.io/asciinema/asciinema-server, in a docker-compose based setup. If you prefer to use a different deployment solution it should be straightforward to adapt the configuration presented below to specifics of your environment.</p> <p>Here's a basic docker-compose configuration for asciinema server you can use as a template.</p> HTTPSHTTP docker-compose.yml<pre><code>services:\n  asciinema:\n    image: ghcr.io/asciinema/asciinema-server:20251114\n    environment:\n      - SECRET_KEY_BASE=  # &lt;- see below\n      - URL_HOST=asciinema.example.com\n      - URL_SCHEME=https\n      - SMTP_HOST=smtp.example.com\n      - SMTP_USERNAME=foobar\n      - SMTP_PASSWORD=hunter2\n    volumes:\n      - asciinema_data:/var/lib/asciinema\n    depends_on:\n      postgres:\n        condition: service_healthy\n\n  postgres:\n    image: docker.io/library/postgres:14\n    environment:\n      - POSTGRES_HOST_AUTH_METHOD=trust\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: ['CMD-SHELL', 'pg_isready -U postgres']\n      interval: 2s\n      timeout: 5s\n      retries: 10\n\n  caddy:\n    image: caddy:2\n    command: caddy reverse-proxy --from https://asciinema.example.com --to http://asciinema:4000\n    ports:\n      - '80:80'\n      - '443:443'\n      - '443:443/udp'\n    volumes:\n      - caddy_data:/data\n      - caddy_config:/config\n\nvolumes:\n  asciinema_data:\n  postgres_data:\n  caddy_data:\n  caddy_config:\n</code></pre> docker-compose.yml<pre><code>services:\n  asciinema:\n    image: ghcr.io/asciinema/asciinema-server:20251114\n    ports:\n      - '80:4000'\n    environment:\n      - SECRET_KEY_BASE=  # &lt;- see below\n      - URL_HOST=asciinema.example.com\n      - URL_PORT=80\n      - SMTP_HOST=smtp.example.com\n      - SMTP_USERNAME=foobar\n      - SMTP_PASSWORD=hunter2\n    volumes:\n      - asciinema_data:/var/lib/asciinema\n    depends_on:\n      postgres:\n        condition: service_healthy\n\n  postgres:\n    image: docker.io/library/postgres:14\n    environment:\n      - POSTGRES_HOST_AUTH_METHOD=trust\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: ['CMD-SHELL', 'pg_isready -U postgres']\n      interval: 2s\n      timeout: 5s\n      retries: 10\n\nvolumes:\n  asciinema_data:\n  postgres_data:\n</code></pre> <p>Let's break it down.</p> <p>The <code>asciinema</code> container uses a server image version tagged <code>20251114</code>. This is merely an example; please check the releases page for the latest stable version number and use that instead.</p> <p>The <code>SECRET_KEY_BASE</code> environment variable is used for encryption/signing of user sessions (amongst other things). You can generate one with the following command:</p> <pre><code>tr -dc A-Za-z0-9 &lt;/dev/urandom | head -c 64; echo\n</code></pre> <p>The <code>URL_SCHEME</code>, <code>URL_HOST</code> and <code>URL_PORT</code> variables configure the root URL used for link generation. The <code>URL_HOST</code> should match the DNS name by which the server is accessible.</p> <p>Check general configuration for more information on <code>SECRET_KEY_BASE</code> and <code>URL_*</code> variables.</p> <p>The <code>SMTP_*</code> variables configure SMTP server used for sending short-lived login links. If you don't set those no mail will be sent. However, you can still obtain a login link from the server logs after entering your email address on the login page. Check email configuration for more details, including configuration examples for popular SMTP providers.</p> <p>The server stores the uploaded recordings and other data at <code>/var/lib/asciinema</code>. We used volume mapping for this directory, but you can also bind-mount it to a directory on the host system, e.g. <code>/path/to/asciinema/data:/var/lib/asciinema</code>, or use S3-compatible object store instead. Check file store configuration for details.</p> <p>The server utilizes PostgreSQL as its database; therefore we have included a dedicated <code>postgres</code> service, mapping its data directory, <code>/var/lib/postgresql/data</code>, to a volume. For convenience, asciinema server container image sets <code>DATABASE_URL</code> to <code>postgresql://postgres@postgres/postgres</code>, enabling it to connect to the <code>postgres</code> container automatically. Check the database configuration for more information on <code>DATABASE_URL</code>, including the use of a separate/external PostgreSQL server.</p> <p>Finally, the <code>caddy</code> service runs Caddy web server in reverse proxy mode, with automatic HTTPS enabled for the domain specified with the <code>--from</code> argument (which should be the same as the <code>URL_HOST</code> on <code>asciinema</code> service). See HTTPS configuration for additional information.</p> <p>Assuming you have set <code>SECRET_KEY_BASE</code> and <code>URL_*</code> variables, and opened ports 80 and 443 in the host system's firewall, you can now launch the stack with:</p> <pre><code>docker compose up\n</code></pre> <p>You will see PostgreSQL perform its initial setup, asciinema server create its database tables, and Caddy attempt to obtain a TLS certificate for your domain. Visit the configured URL in your web browser to verify it's up and running.</p> <p>Congratulations! You have your own asciinema server instance \ud83c\udf89</p> <p>Now, point asciinema CLI to your server by setting <code>ASCIINEMA_API_URL</code>, and upload a recording:</p> CLI 3.xCLI 2.x <pre><code>export ASCIINEMA_SERVER_URL=https://asciinema.example.com\nasciinema upload demo.cast\n</code></pre> <pre><code>export ASCIINEMA_API_URL=https://asciinema.example.com\nasciinema upload demo.cast\n</code></pre> <p>Check the CLI configuration section for information on how to set the server URL permanently via the configuration file.</p>"},{"location":"manual/server/self-hosting/upgrading/","title":"Upgrading","text":"<p>To upgrade your instance of asciinema server to the latest version:</p> <ul> <li>check the releases   for the latest version number</li> <li>check the release notes of all versions between the one you're running and   the one you're upgrading to, and look for manual upgrade steps and breaking   changes for each version - if there are manual steps you omit you may end up   with a broken installation,</li> <li>update the <code>asciinema</code> container image tag to the latest number</li> <li>recreate the stack by running <code>docker compose up -d</code></li> </ul> <p>Release notes for each version include detailed information on the steps needed for a successful upgrade. Backward compatibility is always a high priority when cutting a new release, thus, breaking changes are more the exception than the rule.</p> <p>Usually, it's a matter of updating the container image tag:</p> docker-compose.yml<pre><code> services:\n   asciinema:\n-    image: ghcr.io/asciinema/asciinema-server:20250722\n+    image: ghcr.io/asciinema/asciinema-server:20250915\n     # ...\n</code></pre> <p>Then executing <code>docker compose up -d</code>.</p>"}]}